package {    import flash.net.*;	import flash.utils.*;	import flash.events.*;    public class StreamChecker_lec extends StreamChecker_stu {		private var m_ns_hash:Object; // 監視中のMyNetStreamの連想配列		private var m_prevStatus_hash:Object;  // 監視中のMyNetStreamの連想配列、値は5秒前の生死		//private var m_liveNs_arr:Array; // ストリーム受信中のMyNetStreamの配列				private var m_checkAliveTimer:Timer; // ネットストリームのfpsから出席判定するためのタイマー。引っかかったら「生きてますか？」を発信		private var m_afterKnockTimer:Timer; // 「生きてますか？」を発信してからスタートする、最終的な出席判定をするタイミングをとるタイマー			public function StreamChecker_lec() {			//m_liveNs_arr = new Array();			m_ns_hash = new Object();			m_prevStatus_hash = new Object();						if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) {				m_checkAliveTimer = new Timer( 5000);				m_checkAliveTimer.addEventListener( TimerEvent.TIMER, onTimer);				m_afterKnockTimer = new Timer( 10000, 1);				m_afterKnockTimer.addEventListener( TimerEvent.TIMER, onAfterKnockTimer);			}					}				override protected function onSync1st( e:SyncEvent):void {			super.onSync1st( e);			if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) m_checkAliveTimer.start();		}		override protected function onSync( e:SyncEvent):void {			super.onSync( e);			for each( var obj in e.changeList) {				if( obj.code == "change" && so_knock.data[ obj.name] == true && obj.oldValue == false) {					// 誰かが「はい生きてます」と返事した					if( MyNetStream( m_ns_hash[ obj.name])) {						MyNetStream( m_ns_hash[ obj.name]).setAlive();						dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_ALIVE, obj.name));					}				}			}		}				function onTimer( e:TimerEvent) : void {			var setKnock:Boolean = false;						for each ( var ns:MyNetStream in m_ns_hash) {				var isAlive = checkAlive( ns);				if( m_prevStatus_hash[ ns.getId()] && isAlive == false) {					// [○判定]→[×判定]のとき					if( ns.getId() == Main.CONF.getWhiteboardUID()) {						// 講師からみて、ホワイトボードのステータスがfalseになったときはonAfterKnockTimer判定は省略して、DIE判定						dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, Main.CONF.getWhiteboardUID()));					} else {						so_knock.setProperty( ns.getId(), false);						setKnock = true;					}				}			}			if( setKnock && !Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) {				m_checkAliveTimer.stop();				m_afterKnockTimer.reset();				m_afterKnockTimer.start();			}								/*if( isAlive != m_prevStatus_hash[ ns.getId()]) {				   // ステータスが変わった人がいたとき//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "StreamChecker:onTimer " + ns.getId()+":" + m_prevStatus_hash[ ns.getId()] + "->" + isAlive);				   if( ns.getId() == Main.CONF.getWhiteboardUID() && isAlive == false) {					   // 講師からみて、ホワイトボードのステータスがfalseになったときは					   // onAfterKnockTimerのcheckAliveはどうしtもtrueになってしまう					   // (講師とWBポップアップ画面が同じPCの場合だけだけど)ので					   // onAfterKnockTimer判定は省略して、DIE判定をする					   // これをしないと、WBポップアップ画面を閉じても、WB背景映像が講師映像に切り替わらない					   dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, Main.CONF.getWhiteboardUID()));				   }				   if() {					   if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) m_checkAliveTimer.stop();					   so_knock.setProperty( ns.getId(), isAlive);					   // m_afterKnockTimerが開始する前にso_knockに正しい値が入っているはず					   if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) m_afterKnockTimer.reset();					   if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) m_afterKnockTimer.start();					   setKnock = true;				   }				   				 //  m_prevStatus_hash[ ns.getId()] = isAlive;				}			}*/		}		function onAfterKnockTimer( e:TimerEvent) : void {			for ( var uid:String in so_knock.data) {				var isAlive = so_knock.data[ uid];				if( m_prevStatus_hash[ uid] && isAlive == false) {					// やっぱり[○判定]→[×判定]のままのとき					dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, uid));										MyNetStream( m_ns_hash[ uid]).resetFPS_HISTORY_MAX_COUNT();				}				m_prevStatus_hash[ uid] = isAlive;				/*if( isAlive != m_prevStatus_hash[ ns.getId()]) {					// ステータスが変わってないとき					if( so_knock.data[ ns.getId()] == undefined) {						dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, ns.getId()));					}					// ステータスが変わってるとき//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "StreamChecker:onAfterKnockTimer " + ns.getId()+":" + m_prevStatus_hash[ ns.getId()] + "->" + isAlive);				   				   if( so_knock.data[ ns.getId()] == isAlive) {//alertDialog( ns.getId() + "のonAfterKnockTimer:" + isAlive);									   m_prevStatus_hash[ ns.getId()] = isAlive;					   if( isAlive) dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_ALIVE, ns.getId()));					   else dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, ns.getId()));				   } else {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "StreamChecker:"+ ns.getId() +  ":" + isAlive + " スルーしました" + Math.random());				   }				}*/			}			if( ! Main.DEBUG_CANSEL_TIMER_STREAMCHECKER) {				m_checkAliveTimer.reset();				m_checkAliveTimer.start();			}		}		public function addStream( ns:MyNetStream) {			if( ns == null) return;Main.addDebugMsg( "StreamChecker_lec addStream:" + ns.getId());						m_ns_hash[ ns.getId()] = ns;			m_prevStatus_hash[ ns.getId()] = true;						/*m_prevStatus_hash[ ns.getId()] = ns.currentFPS > 0 ? true : false;						// さいしょの状態をdispatch			if( so_knock == null || so_knock.data == null) {				alertDialog( "addStream() so_knock is null");			}			if( so_knock.data[ ns.getId()] == undefined) {alertDialog( "さいしょの状態をdispatch:" + ns.getId());			   if( m_prevStatus_hash[ ns.getId()] ) dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_ALIVE, ns.getId()));			   else dispatchEvent( new StreamCheckerEvent( StreamCheckerEvent.STATUS_DIE, ns.getId()));			}Main.addDebugMsg( ns.getId() + "のさいしょの状態は:" + m_prevStatus_hash[ ns.getId()] );*/					}		function checkAlive( ns:MyNetStream) : Boolean {			var fps : Number = ns.currentFPS;			if( fps < 0.2) {				return ns.checkFPSHistory();			} else {				return true;			}		}		function alertDialog( str:String) {			Main.addErrMsg( "StreamChecker:" + str);		}	}}