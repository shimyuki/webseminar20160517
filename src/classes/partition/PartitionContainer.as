package partition {	import flash.display.*;	import flash.geom.*;	import flash.events.*;	import flash.utils.*;	import window.whiteboard.imgdoc.ImgdocWindow;	import window.ResizableWindow;	import window.ResizableContainer;		// パーティションによって２分されるコンテナのセット	public class PartitionContainer extends Sprite {		static public const CONTAINER_NAME = "Container in PartitionContainer";		public var MIN_W:Number;		public var MIN_H:Number;		//private var MAX_W:Number;		//private var MAX_H:Number;		private var m_isVertical:Boolean;		protected var m_partition:Partition;		protected var m_container1st; // 左or上		private var m_container1stCon:Sprite; // ただのコンテナ（ポップアップした後戻すときにaddし直す用）		protected var m_container1stMask:Sprite;		protected var m_container2nd; // 右or下		protected var m_container2ndCon:Sprite; // ただのコンテナ（ポップアップした後戻すときにaddし直す用）		protected var m_container2ndMask:Sprite;				protected var m_timer:Timer;				public var dontDispose:Boolean = false;		//		private var m_pre_partitionX:Number = -1;//		private var m_pre_partitionY:Number = -1;				////////////////////////////////		// isVertical==true：パーティションは垂直に設置（左右に分ける）		// isVertical==false：パーティションは水平に設置（上下に分ける）		// container1st : PartitionContainerオブジェクト、若しくはResizableContainer系コンテナ（getViewWidth,getViewHeight,setViewWidth,setViewHeight,MIN_W,MIN_Hを変数に持つ）		// container2nd : PartitionContainerオブジェクト、若しくはResizableContainer系コンテナ（getViewWidth,getViewHeight,setViewWidth,setViewHeight,MIN_W,MIN_Hを変数に持つ）		public function PartitionContainer( _w:Number, _h:Number, isVertical:Boolean, container1st, container2nd, partitionPosi:Number) {//trace("PartitionContainer 1");			m_isVertical = isVertical;			m_container1st = container1st ? container1st : new ResizableContainer(0,0,0,0);			m_container2nd = container2nd ? container2nd : new ResizableContainer(0,0,0,0);			m_container1stCon = Sprite( addChild( new Sprite()));			m_container2ndCon = Sprite( addChild( new Sprite()));			m_container1stCon.addChild( m_container1st);			m_container2ndCon.addChild( m_container2nd);			m_container1stMask = Sprite( addChild( createMask()));			m_container2ndMask = Sprite( addChild( createMask()));			m_container1stCon.mask = m_container1stMask;			m_container2ndCon.mask = m_container2ndMask;			//trace("PartitionContainer 2");						// ポップアップした後戻すとき用に名前をつけとく			m_container1stCon.name = m_container2ndCon.name = CONTAINER_NAME;						// パーティション			m_partition = Partition( addChild( new Partition( isVertical)));				// 最小サイズの設定			resetMin();						// マスク、パーティションの設置			if( m_isVertical) {				m_partition.x = partitionPosi + m_partition.width / 2;				m_partition.height = _h;				m_container1stMask.height = m_container2ndMask.height = _h;				m_container1stMask.width = m_partition.x;				m_container2ndMask.width = _w - ( m_container1stMask.width + m_partition.width);				m_container2ndMask.x = m_partition.x + m_partition.width;			} else {				m_partition.y = partitionPosi + m_partition.height / 2;				m_partition.width = _w;				m_container1stMask.width = m_container2ndMask.width = _w;				m_container1stMask.height = m_partition.y - m_partition.height / 2;				m_container2ndMask.height = _h - ( m_container1stMask.height + m_partition.height / 2);				m_container2ndMask.y = m_partition.y + m_partition.height / 2;			}						m_timer = new Timer( 500, 1);			m_timer.addEventListener( TimerEvent.TIMER, onTimer);									// パーティションのドラッグ開始、コンテナマスクの位置とサイズを変更の監視開始			addEventListener( Event.ADDED_TO_STAGE, onAddedToStage);			addEventListener( Event.REMOVED_FROM_STAGE, function( e:*) {				m_partition.removeEventListener( Partition.ROLL_OVER, onRollOVER);				m_partition.removeEventListener( Partition.ROLL_OUT, onRollOUT);				removeEventListener( Event.ENTER_FRAME, onEnterFrame);				m_timer.stop();				m_partition.setEnabled( false);			});		}		function onTimer( e:TimerEvent) {		   removeEventListener( Event.ENTER_FRAME, onEnterFrame);		   //stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove1st);		}				public function dispose() {			if( dontDispose) return;						m_partition.removeEventListener( Partition.ROLL_OVER, onRollOVER);			m_partition.removeEventListener( Partition.ROLL_OUT, onRollOUT);			removeEventListener( Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener( Event.REMOVED_FROM_STAGE, arguments.callee);			removeEventListener( Event.ENTER_FRAME, onEnterFrame);			m_partition.setEnabled( false);			m_timer.stop();			m_timer.removeEventListener( TimerEvent.TIMER, onTimer);			setCursor( false);			//trace( m_container1st, m_container2nd);			if( m_container1st as PartitionContainer) m_container1st.dispose();			if( m_container2nd as PartitionContainer) m_container2nd.dispose();		}		function onAddedToStage( e:*) {						m_timer.reset();			m_timer.start();			addEventListener( Event.ENTER_FRAME, onEnterFrame);						m_partition.setEnabled( true);			m_partition.addEventListener( Partition.ROLL_OVER, onRollOVER);			m_partition.addEventListener( Partition.ROLL_OUT, onRollOUT);		}				function onRollOVER( e:Event) {			//addEventListener( Event.ENTER_FRAME, onEnterFrame);			dispatchEvent( e);		}				function onRollOUT( e:Event) {			//removeEventListener( Event.ENTER_FRAME, onEnterFrame);			dispatchEvent( e);		}						// 画面モード変更時に呼ばれる		public function init_container2nd( container2nd) {			if( m_container2ndCon.contains( m_container2nd)){				m_container2ndCon.removeChild( m_container2nd);			}			m_container2nd = container2nd;			m_container2ndCon.addChild( m_container2nd);						// 最小サイズの設定			resetMin();					}				// WhiteboardContainerでUIDが生徒の場合、その生徒のホワイトボード権限変更時に呼ばれる		public function init_container1st( container1st) {			if( m_container1stCon.contains( m_container1st)) {				m_container1stCon.removeChild( m_container1st);			}			m_container1st = container1st;			m_container1stCon.addChild( m_container1st);						// 最小サイズの設定			resetMin();		}				function resetMin() {			if( m_isVertical) {				MIN_W = m_container1st.MIN_W + m_container2nd.MIN_W + m_partition.width;				//MAX_W = m_container1st.MAX_W + m_container2nd.MAX_W + m_partition.width;				MIN_H = ( m_container1st.MIN_H < m_container2nd.MIN_H) ? m_container1st.MIN_H : m_container2nd.MIN_H;				//MAX_H = ( m_container1st.MAX_H > m_container2nd.MAX_H) ? m_container1st.MAX_H : m_container2nd.MAX_H;			} else {//alertDialog("koko2:m_container1st.MIN_W=" + String(m_container1st.MIN_W)+" :m_container1st.MIN_H=" + String(m_container1st.MIN_H));//alertDialog("koko2:m_container2nd.MIN_W=" + String(m_container2nd.MIN_W)+" :m_container2nd.MIN_H=" + String(m_container2nd.MIN_H));				MIN_W = ( m_container1st.MIN_W < m_container2nd.MIN_W) ? m_container1st.MIN_W : m_container2nd.MIN_W;				MIN_H = m_container1st.MIN_H + m_container2nd.MIN_H + m_partition.height;			}		}				// PartitionDragManagerから呼ばれる		// パーティションのカーソル表示の有効／無効設定		public function setCursor( b:Boolean) {			m_partition.setEnabled( b);		}				// パーティションのドラッグ中（PartitionDragManagerから呼ばれる）		public function updatePartitionPosi() {			if( m_isVertical) {				m_partition.x = mouseX;			} else {				m_partition.y = getTy( m_partition.y, mouseY);			}		}						function getTy( preY:Number, ty:Number):Number {			if( preY >= ty) {				// パーティションを上に押し上げてるとき				//if( String( describeType( m_container1st).@name) == "PartitionContainer") {				var con1st = m_container1st as PartitionContainer;				if( con1st != null) {					// 押し上げているものがResizableWindowでなくPartitionContainerの場合					if( preY - ty > con1st.getExtraY_2nd()) return preY - con1st.getExtraY_2nd();									}			}						return ty;		}				// 親コンテナからパーティションドラッグ中に呼ばれる		// 2ndコンテナの余分な高さを返す		function getExtraY_2nd():Number {			return m_container2nd.getViewHeight() - m_container2nd.MIN_H;		}				// 親コンテナから呼ばれる		public function setViewWidth( _w:Number, debug:String = ""):void {						if( _w < MIN_W) _w = MIN_W;			if( m_isVertical) {								var wholeWidth = getViewWidth(); // マスクサイズを変更する前に全体幅を記憶しとく				// 変更量				var dx = _w - wholeWidth;				// 右側のコンテナマスクのサイズを変更				m_container2ndMask.width += dx;							} else {				m_container1stMask.width = m_container2ndMask.width = m_partition.width = _w;			}			/*			if( m_container1st as ResizableWindow) {				m_container1st.setViewWidth( m_container1stMask.width);			}			if( m_container2nd as ResizableWindow) {				m_container2nd.setViewWidth( m_container2ndMask.width);			}			*/		}				// 親コンテナから呼ばれる		public function setViewHeight( _h:Number):void {			if( _h < MIN_H) _h = MIN_H;			if( m_isVertical) {				m_container1stMask.height = m_container2ndMask.height = m_partition.height = _h;//if( this as PartitionContainer_allBase) {//	Main.addDebugMsg("PartitionCon:setViewHeight(" + _h + ")");//}			} else {								var wholeHeight = getViewHeight(); // マスクサイズを変更する前に全体高を記憶しとく				// 変更量				var dy = _h - wholeHeight;				// 下側のコンテナマスクのサイズを変更				m_container2ndMask.height += dy;if( name == "main_base leftcolum" && dy != 0) {	//trace(name + ":setViewHeight(" + _h + ") 変更量:" + dy);	//Main.addDebugMsg(name + ":setViewHeight(" + _h + ") 変更量:" + dy);	if( m_container2nd.parent != Main.POPUP_CONTAINER) {		m_container2nd.setViewHeight( m_container2ndMask.height);		( m_container2nd.getContents()).setViewHeight( m_container2ndMask.height - Main.TITLE_BAR_H);	}}					}			/*			if( m_container1st as ResizableWindow) {				m_container1st.setViewHeight( m_container1stMask.height);			}			if( m_container2nd as ResizableWindow) {				m_container2nd.setViewHeight( m_container2ndMask.height);			}*/		}						// 全体マスク領域の幅を返す		public function getViewWidth() :Number {			if( m_isVertical) {				return m_container2ndMask.x + m_container2ndMask.width - m_container1stMask.x;			} else {				return m_container1stMask.width - m_container1stMask.x;			}		}				// 全体マスク領域の高さを返す		public function getViewHeight() :Number {			if( m_isVertical) {				return m_container1stMask.height - m_container1stMask.y;			} else {				return m_container2ndMask.y + m_container2ndMask.height - m_container1stMask.y;			}		}				// stage上のいずれかのパーティションのROLL_OVERにPartitionDragManagerから呼ばれる		public function startEnterFrame() {			addEventListener( Event.ENTER_FRAME, onEnterFrame);		}		// stage上のいずれかのパーティションのROLL_OUT時にPartitionDragManagerから呼ばれる		public function stopEnterFrame() {			removeEventListener( Event.ENTER_FRAME, onEnterFrame);		}				// onResize時にPartitionContainer_allBaseから呼ばれる		public function replace_once() {			replace();		}				function onEnterFrame( e:Event):void {			replace();		}		public function replace():void {						// パーティションの位置制限の設定			var partitionPosi_min;			var partitionPosi_max;			if( m_isVertical) {				partitionPosi_min = m_container1st.MIN_W + m_partition.width / 2;				partitionPosi_max = getViewWidth() - m_container2nd.MIN_W - m_partition.width / 2;			} else {				partitionPosi_min = m_container1st.MIN_H + m_partition.height / 2;				partitionPosi_max = getViewHeight() - m_container2nd.MIN_H - m_partition.height / 2;			}									// パーティションの位置補正			if( m_isVertical) {				if( m_partition.x < partitionPosi_min) m_partition.x = partitionPosi_min;				else if( m_partition.x > partitionPosi_max) m_partition.x = partitionPosi_max;			} else {				if( m_partition.y < partitionPosi_min) m_partition.y = partitionPosi_min;				else if( m_partition.y > partitionPosi_max) m_partition.y = partitionPosi_max;			}									// パーティションの位置からコンテナマスクの位置とサイズを変更する			if( m_isVertical) {				var wholeWidth = getViewWidth(); // マスク位置を変更する前に全体幅を記憶しとく				m_container2ndCon.x = m_partition.x + m_partition.width / 2;				m_container1stMask.width = m_partition.x - m_partition.width / 2;				m_container2ndMask.x = m_container2ndCon.x;				m_container2ndMask.width = wholeWidth - m_container2ndCon.x;			} else {				var wholeHeight = getViewHeight(); // マスク位置を変更する前に全体高さを記憶しとく				m_container2ndCon.y = m_partition.y + m_partition.height / 2;				m_container1stMask.height = m_partition.y - m_partition.height / 2;				m_container2ndMask.y = m_container2ndCon.y;				m_container2ndMask.height = wholeHeight - m_container2ndCon.y;			}						/*if( m_container1st as PartitionContainer != null			   && PartitionContainer( m_container1st).m_container2nd.name == Layout.SUB_WINNAME_WHITEBOARD_IMGDOC			   && PartitionContainer( m_container1st).m_container2nd.parent.name != CONTAINER_NAME) {				//alertDialog( "koko1");				return;			}			if( m_container2nd as ImgdocWindow != null			   && m_container2nd.parent.name != CONTAINER_NAME) {				//alertDialog( "koko2");				if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", m_container2nd.parent +" "+ Math.random());				return;			}*/						// 子コンテナの全体表示幅を変更			// ただしポップアップ中のコンテナに関しては変えない			if( m_container1st.parent.name == CONTAINER_NAME) {												m_container1st.setViewWidth( m_container1stMask.width);				m_container1st.setViewHeight( m_container1stMask.height);				var chk = false;				// 押し上げられているとき				if( !m_isVertical && m_container1st.getViewHeight() > m_container1stMask.height) {					var con1st = m_container1st as PartitionContainer;					if( con1st != null) {						// 押し上げているものがResizableWindowでなくPartitionContainerの場合						if( m_container1st.getViewHeight() - m_container1stMask.height > con1st.getExtraY_2nd()) {							// 上のPartitionContainerの2ndコンテナのMIN_H以上に押し上げられているとき							chk = true;						}											}				}				if( chk) {					var new_h = m_container1st.getViewHeight() - con1st.getExtraY_2nd(); // ぎりぎりのY					var old_h = m_container1stMask.height; // 行き過ぎたY					m_container1stMask.height = new_h;					m_container1st.setViewHeight( new_h);					m_partition.y += new_h - old_h; // 上に行き過ぎていた分、パーティションの位置を戻す					m_container2ndMask.height -= ( new_h - old_h);				}				else m_container1st.setViewHeight( m_container1stMask.height);			}			if( m_container2nd.parent.name == CONTAINER_NAME) {				m_container2nd.setViewWidth( m_container2ndMask.width);				m_container2nd.setViewHeight( m_container2ndMask.height);				if( m_container2nd as PartitionContainer) {					PartitionContainer( m_container2nd).replace_once();				}			}			//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "PartitionContainer:koko2 " + Math.random());					}						function createMask() : Sprite {			var msk:Sprite = new Sprite();			msk.graphics.beginFill( 0);			msk.graphics.drawRect( 0, 0, 1, 1);			msk.graphics.endFill();			return msk;		}		function alertDialog( str:String) {			Main.addErrMsg( "PartitionContainer:" + str);		}	}}