package window.header {	import flash.display.*;	import flash.text.*;	import flash.events.*;	import flash.geom.*;	import common.*;	import caurina.transitions.*;	import flash.utils.Timer;		public class RecBtn extends Sprite {		private const STR_OFF:String = Main.LANG.getParam( "録画する");		private const STR_OVER:String = STR_OFF;		private const STR_ON:String = Main.LANG.getParam( "録画中...");		private const STR_ON_OVER:String = Main.LANG.getParam( "録画停止");		private const STR_WAITING:String = Main.LANG.getParam( "録画準備中");		protected var m_on:Sprite;		protected var m_off:Sprite;		private var m_over:Sprite;		protected var m_waiting:Sprite;		private var m_clickObj:Sprite;		protected const FONT_SIZE:Number = 11;		protected const FONT_COLOR:uint = 0xffffff;		protected const BASE_COLOR_01:uint = Main.MAIN_COLOR_02;//0xa0b7ce;		protected const BASE_COLOR_02:uint = Main.MAIN_COLOR_02;//0x7f9bb9;		protected const ELLIPSE_W:Number = 10;		private var m_iconRec_on;		private var m_onTxt:TextField;		private var m_onOverTxt:TextField;				public function RecBtn() {		}		public function initAsNormal( h:Number) {						// テキスト			// OFF			var offTxt:TextField = new TextField();			offTxt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), FONT_SIZE, FONT_COLOR, true);			offTxt.autoSize = TextFieldAutoSize.LEFT;			offTxt.text = STR_OFF;			offTxt.selectable = offTxt.mouseEnabled = false;			//OVER			var overTxt:TextField = new TextField();			overTxt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), FONT_SIZE, FONT_COLOR, true);			overTxt.autoSize = TextFieldAutoSize.LEFT;			overTxt.text = STR_OVER;			overTxt.selectable = overTxt.mouseEnabled = false;			//WAITING			var waitingTxt:TextField = new TextField();			waitingTxt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), FONT_SIZE, FONT_COLOR, true);			waitingTxt.autoSize = TextFieldAutoSize.LEFT;			waitingTxt.text = STR_WAITING;			waitingTxt.selectable = waitingTxt.mouseEnabled = false;			//ON			m_onTxt = new TextField();			m_onTxt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), FONT_SIZE, FONT_COLOR, true);			m_onTxt.autoSize = TextFieldAutoSize.LEFT;			m_onTxt.text = STR_ON;			m_onTxt.selectable = m_onTxt.mouseEnabled = false;			//STR_ON_OVER			m_onOverTxt = new TextField();			m_onOverTxt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), FONT_SIZE, FONT_COLOR, true);			m_onOverTxt.autoSize = TextFieldAutoSize.LEFT;			m_onOverTxt.text = STR_ON_OVER;			m_onOverTxt.selectable = m_onOverTxt.mouseEnabled = false;			m_onOverTxt.visible = false;						var text_width:Number = offTxt.width > overTxt.width ? offTxt.width : overTxt.width;			text_width = text_width > m_onTxt.width ? text_width : m_onTxt.width;			text_width = text_width > m_onOverTxt.width ? text_width : m_onOverTxt.width;			text_width = text_width > waitingTxt.width ? text_width : waitingTxt.width;			var w:Number = text_width + IconRec.W + 15;						// OFFベース			m_off = Sprite( addChild( new Sprite()));			var matrix:Matrix = new Matrix();			matrix.createGradientBox( w, h, - Math.PI / 2);			m_off.graphics.beginGradientFill( GradientType.LINEAR,											[BASE_COLOR_02, BASE_COLOR_01],											[1, 1],											[0x00, 0xFF],											matrix, SpreadMethod.PAD);			m_off.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			m_off.graphics.endFill();						// OFFの録画アイコン			var iconRec_off = m_off.addChild( new IconRec( IconRec.OFF));			iconRec_off.x = 6 + IconRec.W / 2;			iconRec_off.y = h / 2;			//iconRec_off.alpha = 0.4;						m_off.addChild( offTxt);			offTxt.x = iconRec_off.x + 8;			offTxt.y = ( h - offTxt.height) / 2;						// OVERベース			m_over = Sprite( addChild( new Sprite()));			m_over.graphics.beginGradientFill( GradientType.LINEAR,											[BASE_COLOR_01, BASE_COLOR_02],											[1, 1],											[0x00, 0xFF],											matrix, SpreadMethod.PAD);			m_over.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			m_over.graphics.endFill();			m_over.visible = false;						// OVERの録画アイコン			var iconRec_over = m_over.addChild( new IconRec( IconRec.OVER));			iconRec_over.x = 6 + IconRec.W / 2;			iconRec_over.y = h / 2;					m_over.addChild( overTxt)			overTxt.x = iconRec_over.x + 8;			overTxt.y = ( h - overTxt.height) / 2;									// WATINGベース			m_waiting = Sprite( addChild( new Sprite()));			m_waiting.visible = false;			m_waiting.graphics.beginGradientFill( GradientType.LINEAR,											[BASE_COLOR_01, BASE_COLOR_02],											[1, 1],											[0x00, 0xFF],											matrix, SpreadMethod.PAD);			m_waiting.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			m_waiting.graphics.endFill();			m_waiting.visible = false;						// WATINGの録画アイコン			var iconRec_wating = m_waiting.addChild( new IconRec( IconRec.WAITING));			iconRec_wating.x = 6 + IconRec.W / 2;			iconRec_wating.y = h / 2;					m_waiting.addChild( waitingTxt)			waitingTxt.x = iconRec_wating.x + 8;			waitingTxt.y = ( h - waitingTxt.height) / 2;									// ONベース			m_on = Sprite( addChild( getOnBase( w, h, matrix)));			m_on.visible = false;						// ONの録画アイコン			m_iconRec_on = m_on.addChild( new IconRec( IconRec.ON));			m_iconRec_on.x = 6 + IconRec.W / 2;			m_iconRec_on.y = h / 2;								m_on.addChild( m_onTxt);			m_onTxt.x = m_iconRec_on.x + 8;			m_onTxt.y = ( h - m_onTxt.height) / 2;			m_on.addChild( m_onOverTxt);			m_onOverTxt.x = m_iconRec_on.x + 8;			m_onOverTxt.y = ( h - m_onOverTxt.height) / 2;						m_clickObj = Sprite( addChild( new Sprite()));			m_clickObj.graphics.beginFill( 0, 0);			m_clickObj.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			m_clickObj.graphics.endFill();						buttonMode = true;					}				public function isOn() :Boolean {			return m_on.visible;		}		public function wait() {			m_waiting.visible = true;			m_on.visible = false;		}		public function isWaiting() :Boolean {			return m_waiting.visible;		}				public function on() {			m_on.visible = true;			m_waiting.visible = false;			// ピコピコ動かす			//Tweener.addTween( m_iconRec_on, { y:m_hand_initY - 3, transition:"easeOutQuint", time:0.5, delay:2, onComplete:onComplete_01});			//buttonMode = false;		}				public function off() {			m_on.visible = false;			m_waiting.visible = false;			//Tweener.removeTweens( m_iconRec_on);			//buttonMode = true;		}		/*		function onComplete_01() {			m_iconRec_on.y = m_hand_initY - 1;			Tweener.addTween( m_iconRec_on, { y:m_hand_initY - 3, transition:"easeOutQuint", time:0.5, onComplete:onComplete_02});		}		function onComplete_02() {			Tweener.addTween( m_iconRec_on, { y:m_hand_initY, transition:"easeOutBounce", time:0.5, onComplete:onComplete_03});		}		function onComplete_03() {			Tweener.addTween( m_iconRec_on, { y:m_hand_initY - 3, transition:"easeOutQuint", time:0.5, delay:3, onComplete:onComplete_01});		}		*/				protected function getOnBase( w:Number, h:Number, matrix:Matrix) : Sprite {			var onBase:Sprite = new Sprite();			onBase.graphics.beginFill( 0xffffff);			onBase.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			onBase.graphics.endFill();			var onBaseRed:Sprite = Sprite( onBase.addChild( new Sprite()));			onBaseRed.graphics.beginGradientFill( GradientType.LINEAR,											[0xb50000, 0xcc0000],											[1, 1],											[0x00, 0xFF],											matrix, SpreadMethod.PAD);			onBaseRed.graphics.drawRoundRect( 0, 0, w, h, ELLIPSE_W);			onBaseRed.graphics.endFill();						return onBase;		}				public function setEnabled( b:Boolean):void {			buttonMode = b;			if( b) {				m_clickObj.addEventListener( MouseEvent.ROLL_OVER, onRollOVER);				m_clickObj.addEventListener( MouseEvent.ROLL_OUT, onRollOUT);			} else {				m_clickObj.removeEventListener( MouseEvent.ROLL_OVER, onRollOVER);				m_clickObj.removeEventListener( MouseEvent.ROLL_OUT, onRollOUT);				onRollOUT();			}		}		function onRollOVER( e:MouseEvent) {			if( isWaiting()) return;						if( isOn()) {				m_onOverTxt.visible = true;				m_onTxt.visible = false;			} else {				m_onOverTxt.visible = false;				m_onTxt.visible = true;			}			m_over.visible = true;		}		function onRollOUT( e:MouseEvent = null) {			if( isWaiting()) return;						m_over.visible = false;			m_onOverTxt.visible = false;			m_onTxt.visible = true;		}	}}