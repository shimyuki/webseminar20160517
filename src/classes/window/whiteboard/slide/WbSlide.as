package window.whiteboard.slide {	import flash.display.*;	import flash.geom.*;	import flash.ui.Keyboard;	import common.*;	import window.whiteboard.*;	import flash.events.*;	import flash.ui.Mouse;	import window.whiteboard.toolchip.ToolModeDetail;	import flash.text.*;	import flash.net.NetConnection;		// ホワイトボードに表示する１枚のスライド	public class WbSlide extends Sprite {		static public const BG_COMPLETE:String = "BG_COMPLETE";		static public const CHANGE_SIZE:String = "CHANGE_SIZE";		static public const CHANGE_PP:String = "CHANGE_PP";		//static public const REMOVED_PP:String = "REMOVED_PP";		static public const CHANGE_SIZE_BY_COMBO:String = "CHANGE_SIZE_BY_COMBO";		static public const CHANGE_PP_LOCAL:String = "CHANGE_PP_LOCAL";				private var m_container:Sprite; // 背景資料とペイントパーツたちが乗る、スケール変更用コンテナ		protected var m_bg:Sprite; // 背景（画像か無地かカメラ映像かが乗る）		private var MIN_SCALE:Number = 0.05;		private var MAX_SCALE:Number = 3;		protected var m_bgtype:String;		private const ZOOM_DIFF:Number = 0.1;				private var m_toolModeDetail:ToolModeDetail = null; // 現在のペイントツールモード		private var m_pointer = null; // ペイントツールモードによっていろいろなポインタが入る		private var m_viewX:Number;		private var m_viewY:Number;		protected var m_viewW:Number;		protected var m_viewH:Number;				protected var m_livePointerCon:LivePointerContainer; // ライブポインタが乗るコンテナ		private var m_paintCon:Sprite; // ペイントパーツが乗るコンテナ		private var m_paintCon_local:Sprite; // ローカルのペイントパーツが乗るコンテナ（マイWB）				private var m_parentX:Number = 0;		private var m_parentY:Number = 0;				private var m_selectBox:SelectBox; // 選択ボックス		private var m_shiftKey:Boolean = false; // SHIFTキーが押されている状態か、監視		private var m_ctlKey:Boolean = false; // CTLキーが押されている状態か、監視				private var m_mouseStatus:uint = 999;				private const SMOOTH_LEVEL = 1;		private var m_smoothLineToArr:Array = null;		private var m_smoothSkipedCnt:int;		private var m_ttlSmoothLineTo:Object;				private var m_lastPpStatus:String = "描画前";				private var m_redoPpArr:Array; // 削除されたPPの配列。もとに戻すように保管する。		private var m_redoPpArr_local:Array;								public function WbSlide( bgtype:String) {			m_bgtype = bgtype;						m_container = Sprite( addChild( new Sprite()));			m_bg = Sprite( m_container.addChild( new Sprite())); // (0,0)に背景（画像かカメラ映像か）が置かれる			m_paintCon = Sprite( m_container.addChild( new Sprite())); // お絵描き用コンテナ			m_paintCon_local = Sprite( m_container.addChild( new Sprite())); // ローカルお絵描き用コンテナ			m_livePointerCon = LivePointerContainer( m_container.addChild( new LivePointerContainer())); // ライブポインタが乗るコンテナ						m_selectBox = SelectBox( addChild( new SelectBox( m_container)));						m_redoPpArr = new Array();			m_redoPpArr_local = new Array();						addEventListener( Event.ADDED_TO_STAGE,							 function( e:Event) {								addEventListener( Event.ENTER_FRAME, onEnterFrame);								//stage.addEventListener( MouseEvent.MOUSE_MOVE, onEnterFrame);								stage.addEventListener( MouseEvent.MOUSE_DOWN, watchStart);								stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyboardDown);								stage.addEventListener( KeyboardEvent.KEY_UP, onKeyboardUp);								m_selectBox.addEventListener( PaintPartsEvent.MULTI_CHANGE, onMultiChangePP);								parent.x = m_parentX;								parent.y = m_parentY;															 });			addEventListener( Event.REMOVED_FROM_STAGE,							 function( e:Event) {								onFix_drawLine();								onFix_drawSquare();								onFix_drawCircle();								onFix_drawFreeLine();								showCursor();								removeEventListener( Event.ENTER_FRAME, onEnterFrame);								//stage.removeEventListener( MouseEvent.MOUSE_MOVE, onEnterFrame);								stage.removeEventListener( MouseEvent.MOUSE_DOWN, watchStart);								stage.removeEventListener( KeyboardEvent.KEY_DOWN, onKeyboardDown);								stage.removeEventListener( KeyboardEvent.KEY_UP, onKeyboardUp);								m_selectBox.removeEventListener( PaintPartsEvent.MULTI_CHANGE, onMultiChangePP);								m_pointer = null;								m_selectBox.removeAllPaintParts();							 });		}						// ホワイトボード書き込み権限が変更されたときにWhiteboardContainer経由でWhiteboardから呼ばれる		public function setAuthority( b:Boolean) {//alertDialog("ホワイトボード書き込み権限: " + b);			// 書きかけのペイントパーツの描画はいったん終了			if( m_lastPpStatus != "描画前" && m_lastPpStatus != "描画終了") {				forceFix();				m_lastPpStatus = "描画終了";			}						//m_paintCon.visible = b;			m_paintCon_local.visible = !b;		}		/*		// 背景部分を中心揃え（ペイントパーツを無視して）にするためにWhiteboard:onCompleteから呼ばれる。		public function getPPConRect() : Rectangle {			var rect:Rectangle = m_paintCon.getRect( m_container);			return rect;		}*/				function onMultiChangePP( e:PaintPartsEvent) {			if( WhiteboardContainer.WB_AUTHORIZED) dispatchEvent( new PaintPartsEvent( e.type, e.paintPartsData));			else dispatchEvent( new Event( CHANGE_PP_LOCAL));		}		function onKeyboardDown( e:KeyboardEvent):void {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var i:uint;			var pp:PaintParts;//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onKeyboardDown() e.keyCode:" + e.keyCode + "/ e.shiftKey:" + String(e.shiftKey) + "/ e.ctrlKey:" + String(e.ctrlKey));			if( e.keyCode == Keyboard.DELETE || e.keyCode == Keyboard.BACKSPACE) {				// 選択されているペイントパーツを削除				for( i = 0; i < paintCon.numChildren; i++) {					pp = paintCon.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( ! m_selectBox.isAdded( pp)) continue;										pp.setVisible( false);					if( WhiteboardContainer.WB_AUTHORIZED) dispatchEvent( new PaintPartsEvent( PaintPartsEvent.REMOVED, pp.getPaintPartsData()));					else dispatchEvent( new Event( CHANGE_PP_LOCAL));				}				m_selectBox.removeAllPaintParts();				//dispatchEvent( new Event( REMOVED_PP));			} else if( m_ctlKey && e.keyCode == 90) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onKeyboardDown() CTL+Z");				// Ctl + Z				clearLastPaintParts();							} else if( ! e.shiftKey){				m_selectBox.removeAllPaintParts();			}						if( e.shiftKey) m_shiftKey = true;			if( e.ctrlKey) m_ctlKey = true;//if( m_ctlKey) if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "+ CTL" + String( e.keyCode));//else if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "- CTL" + String( e.keyCode));		}				public function clearLastPaintParts() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			// 最後に追加されたペイントパーツを削除			for( var i:uint = paintCon.numChildren - 1; i >= 0; i--) {				var pp:PaintParts = paintCon.getChildAt( i) as PaintParts;				if( pp == null) continue;				if( ! pp.visible) continue;				pp.setVisible( false);				if( WhiteboardContainer.WB_AUTHORIZED) m_redoPpArr.push( pp);				else m_redoPpArr_local.push( pp);				if( WhiteboardContainer.WB_AUTHORIZED) dispatchEvent( new PaintPartsEvent( PaintPartsEvent.REMOVED, pp.getPaintPartsData()));				else dispatchEvent( new Event( CHANGE_PP_LOCAL));				break;			}			m_selectBox.removeAllPaintParts();		}				// clearLastPaintPartsで削除したペイントパーツを元に戻す		public function redoClearedPaintParts() {			var pp:PaintParts;			if( WhiteboardContainer.WB_AUTHORIZED) {				if( m_redoPpArr.length == 0) return;				pp = PaintParts( m_redoPpArr.pop());				pp.setVisible( true);				dispatchEvent( new PaintPartsEvent( PaintPartsEvent.CHANGED, pp.getPaintPartsData()));			} else {				if( m_redoPpArr_local.length == 0) return;				pp = PaintParts( m_redoPpArr_local.pop());				pp.setVisible( true);				dispatchEvent( new Event( CHANGE_PP_LOCAL));			}			m_selectBox.removeAllPaintParts();		}		/*function redo( pp:PaintParts, paintCon) {			for( var i:uint = paintCon.numChildren - 1; i >= 0; i--) {				var pp:PaintParts = paintCon.getChildAt( i) as PaintParts;				if( pp == null) continue;				if( ! pp.visible) continue;				pp.setVisible( false);				if( WhiteboardContainer.WB_AUTHORIZED) m_redoPpArr.push( pp);				else m_redoPpArr.push( pp);				dispatchEvent( new PaintPartsEvent( PaintPartsEvent.REMOVED, pp.getPaintPartsData()));				break;			}		}*/		function clearRedoPpArr() {			// 元に戻すボタンの履歴を削除			if( WhiteboardContainer.WB_AUTHORIZED) m_redoPpArr = [];			else m_redoPpArr_local = [];						// visible==falseのペイントパーツをremoveChildする			removePpIfUnvisible( WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local);					}		function removePpIfUnvisible( paintCon) {			for( var i:uint = 0; i < paintCon.numChildren; i++) {				var pp:PaintParts = paintCon.getChildAt( i) as PaintParts;				if( pp == null) continue;				pp.removeIfUnvisible();			}		}		function onKeyboardUp( e:KeyboardEvent):void {			if( e.keyCode == Keyboard.SHIFT) m_shiftKey = false;			if( e.keyCode == Keyboard.CONTROL) m_ctlKey = false;//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "e.keyCode:" + e.keyCode + "/ e.shiftKey:" + String(e.shiftKey) + "/ e.ctrlKey:" + String(e.ctrlKey));//if( ! m_ctlKey) if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "- CTL");		}						// WhiteboardのhideSlide()で呼ばれる		// 次回このスライドを表示させるときに親（m_container）の座標も		// 再設定するので親の座標を覚えておく		public function setParentPosi( parentX:Number, parentY:Number) {			m_parentX = parentX;			m_parentY = parentY;		}				// WhiteboardのonComplete()で呼ばれる		// スライド自身はWhiteboardのm_containerにADD済みで、背景の読み込みが完了した時		// 親の座標（Whiteboardのm_container）がまだ指定されていない場合（0,0の場合）true		public function isParentPosiSet():Boolean {			if( m_parentX == 0 && m_parentY == 0) return false;			else return true;		}				// WhitebordのsetToolModeDetail()：ツールチップボタンクリック時と		// WhiteboardContainerのso_wbNow変更時に呼ばれる		public function setToolModeDetail( toolModeDetail:ToolModeDetail) : void {			resetToolMode( toolModeDetail);						m_selectBox.removeAllPaintParts();		}				// WhitebordのonChangeWbSlidePPから一時的にm_selectBoxをはずして		// getBoundsするためによばれる。		public function removeSelectBoxTemporary() : void {			if( contains( m_selectBox)) removeChild( m_selectBox);			if( m_container.contains( m_livePointerCon)) m_container.removeChild( m_livePointerCon);					}		public function addSelectBoxTemporary() : void {			addChild( m_selectBox);			m_container.addChild( m_livePointerCon);		}		// WhitebordのonChangeWbSlidePPからよばれる。		public function containsPaintParts() : Boolean {			var pp:PaintParts;			var i:uint;			if( WhiteboardContainer.WB_AUTHORIZED) {				//if( m_paintCon.numChildren) return true;				for( i = 0; i < m_paintCon.numChildren; i++) {					pp = m_paintCon.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( pp.visible) return true;				}			} else {				//if( m_paintCon.numChildren + m_paintCon_local.numChildren) return true;				for( i = 0; i < m_paintCon.numChildren; i++) {					pp = m_paintCon.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( pp.visible) return true;				}				for( i = 0; i < m_paintCon_local.numChildren; i++) {					pp = m_paintCon_local.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( pp.visible) return true;				}			}			return false;		}		// WhiteboardContainerからWhitebord経由で戻る進むボタンの初期設定時に呼ばれる		// backできる状態か		public function canBack() : Boolean {			var i:uint;			var pp:PaintParts;			if( WhiteboardContainer.WB_AUTHORIZED) {				//return m_paintCon.numChildren > 0 ? true : false;				for( i = 0; i < m_paintCon.numChildren; i++) {					pp = m_paintCon.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( pp.visible) return true;				}			} else {				//return m_paintCon_local.numChildren > 0 ? true : false;				for( i = 0; i < m_paintCon_local.numChildren; i++) {					pp = m_paintCon_local.getChildAt( i) as PaintParts;					if( pp == null) continue;					if( pp.visible) return true;				}			}			return false;		}		// WhiteboardContainerからWhitebord経由で戻る進むボタンの初期設定時に呼ばれる		// redoできる状態か		public function canRedo() : Boolean {			if( WhiteboardContainer.WB_AUTHORIZED) {				return m_redoPpArr.length > 0 ? true : false;			} else {				return m_redoPpArr_local.length > 0 ? true : false;			}		}		// マウスの位置がホワイトボード領域内に収まっているか		// ペイントツールの線の太さなども考慮する		function isPaintable() : Boolean {			var bias:Number = 0;			if( m_toolModeDetail != null) {				switch( m_toolModeDetail.tool_name) {					case WhiteboardContainer.TOOL_ARROW:					case WhiteboardContainer.TOOL_ZOOMIN:					case WhiteboardContainer.TOOL_ZOOMOUT:						break;					case WhiteboardContainer.TOOL_PENCIL:					case WhiteboardContainer.TOOL_SMOOTH:					case WhiteboardContainer.TOOL_LINE:					case WhiteboardContainer.TOOL_SQUARE:					case WhiteboardContainer.TOOL_CIRCLE:						bias = m_toolModeDetail.lineweight;						break;					case WhiteboardContainer.TOOL_ERASER:						bias = m_toolModeDetail.lineweight / 2;						break;					case WhiteboardContainer.TOOL_TEXT:						break;					default: break;				}			}			return ( m_viewX + bias < mouseX					&& mouseX < m_viewX + m_viewW - bias					&& m_viewY + bias < mouseY					&& mouseY < m_viewY + m_viewH - bias);					}				function watchStart( e:MouseEvent) {//alertDialog("watchStart: " + WhiteboardContainer.WB_AUTHORIZED);						setPPSelectable(); // TOOL_ARROW以外の場合はペイントパーツ選択不可に。//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "watchStart start" + String(m_pointer) + "/" + String(stage.contains( m_pointer)));							if( m_pointer == null || ! stage.contains( m_pointer)) return;//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "watchStart 1");							//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "watchStart 2");										if( isPaintable() ) {				switch( m_toolModeDetail.tool_name) {					case WhiteboardContainer.TOOL_ARROW:						setPPSelectable();						break;					case WhiteboardContainer.TOOL_PENCIL:					case WhiteboardContainer.TOOL_ERASER:						start_drawFreeLine();						break;					case WhiteboardContainer.TOOL_SMOOTH:						start_drawSmoothLine();						break;					case WhiteboardContainer.TOOL_ZOOMIN:						zoom( true);						break;					case WhiteboardContainer.TOOL_ZOOMOUT:						zoom( false);						break;					case WhiteboardContainer.TOOL_LINE:						start_drawLine();						break;					case WhiteboardContainer.TOOL_SQUARE:						start_drawSquare();						break;					case WhiteboardContainer.TOOL_CIRCLE:						start_drawCircle();						break;					case WhiteboardContainer.TOOL_TEXT:						start_inputText();						break;					default: break;				}			}//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "watchStart 3");						}				// テキスト入力開始		function start_inputText() {					var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_TEXT, paintCon.numChildren)));			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;						// ペイントデータ保存			base.setFillcolor( m_toolModeDetail.fillcolor);			base.setFontname( m_toolModeDetail.fontname);			base.setFontsize( m_toolModeDetail.fontsize);			base.setFontbold( m_toolModeDetail.fontbold);			base.setPosi( base.x, base.y);						base.setTextField();						// テキスト入力中はポインタを非表示にし、通常のステージのクリック監視（watchStart）もストップ			m_pointer.visible = false;			stage.removeEventListener( MouseEvent.MOUSE_DOWN, watchStart);			// ステージがクリックされたら、入力テキストからフォーカスを外す			stage.addEventListener( MouseEvent.MOUSE_DOWN, focusOutFromText);			base.addEventListener( PaintParts.TEXT_FIXED, onFixTextField);								}		function onFixTextField( e:Event) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "テキストFIX start");				var base:PaintParts = e.target as PaintParts;			if( base == null) {				Main.addErrMsg( "WbSlide:onFixTextField() fatal error");			}						base.removeEventListener( PaintParts.TEXT_FIXED, onFixTextField);			m_pointer.visible = true;			stage.removeEventListener( MouseEvent.MOUSE_DOWN, focusOutFromText);			stage.addEventListener( MouseEvent.MOUSE_DOWN, watchStart);			//stage.dispatchEvent( new MouseEvent( MouseEvent.MOUSE_DOWN));			onFix( base);//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onFixTextField() テキストFIX！！！");	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "テキストFIX");			}				// ダブルクリックでテキストが編集されようとしているとき		function start_textChange( e:Event) {//alertDialog( "ダブルクリックでテキスト編集開始0");				var pp:PaintParts = PaintParts( e.target);			pp.addEventListener( PaintParts.TEXT_CHANGED, onChangeTextField);						// ツールモードをテキストツールに変更させる			dispatchEvent( new TextPaintPartsEvent( TextPaintPartsEvent.START_CHANGE, pp.getPaintPartsData()));						// テキスト入力中はポインタを非表示にし、通常のステージのクリック監視（watchStart）もストップ			m_pointer.visible = false;			stage.removeEventListener( MouseEvent.MOUSE_DOWN, watchStart);			// ステージがクリックされたら、入力テキストからフォーカスを外す			stage.addEventListener( MouseEvent.MOUSE_DOWN, focusOutFromText);//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "ダブルクリックでテキスト編集開始1");						}		// ダブルクリックでテキストが編集されて、編集が完了したとき		function onChangeTextField( e:Event) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "ダブルクリックでテキスト編集完了0");				var pp:PaintParts = PaintParts( e.target);			//pp.removeEventListener( PaintParts.TEXT_CHANGED, onChangeTextField);						if( pp == null) {				Main.addErrMsg( "WbSlide:onChangeTextField() fatal error");			}			m_pointer.visible = true;			stage.removeEventListener( MouseEvent.MOUSE_DOWN, focusOutFromText);			stage.addEventListener( MouseEvent.MOUSE_DOWN, watchStart);			//stage.dispatchEvent( new MouseEvent( MouseEvent.MOUSE_DOWN));						dispatchEvent( new PaintPartsEvent( PaintPartsEvent.CHANGED, pp.getPaintPartsData()));//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "ダブルクリックでテキスト編集完了1");			}				function focusOutFromText( e:MouseEvent) {			if( stage && stage.focus != null) {				stage.removeEventListener( MouseEvent.MOUSE_DOWN, focusOutFromText);				var base:PaintParts = stage.focus.parent as PaintParts;				if( base != null) base.setTextFieldFocusOut();				//else if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:focusOutFromText() 予期しないエラー0");			} else {				Main.addErrMsg(  "WbSlide:focusOutFromText() fatal error1");			}					}				// ズーム		function zoom( zoomin:Boolean) {			var zoom_diff = zoomin ? ZOOM_DIFF : - ZOOM_DIFF;			m_container.scaleY += zoom_diff;			if( m_container.scaleY > MAX_SCALE) m_container.scaleY = MAX_SCALE;			if( m_container.scaleY < MIN_SCALE) m_container.scaleY = MIN_SCALE;			m_container.scaleX = m_container.scaleY;									dispatchEvent( new Event( CHANGE_SIZE));		}				// 直線スタート		function start_drawLine() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_LINE, paintCon.numChildren)));			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, 1, false, "none");			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawLine);			stage.addEventListener( MouseEvent.MOUSE_UP, onFix_drawLine);			stage.addEventListener( MouseEvent.CLICK, onFix_drawLine);			stage.addEventListener( MouseEvent.ROLL_OUT, onFix_drawLine);			stage.addEventListener( Event.MOUSE_LEAVE, onFix_drawLine);						// ペイントデータ保存1			base.setLineweight( m_toolModeDetail.lineweight);			base.setLinecolor( m_toolModeDetail.linecolor);			base.setPosi( base.x, base.y);						m_lastPpStatus = "描画中";		}		// 直線描き直し		function onMouseMove_drawLine( e:*) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						if( ! isPaintable()) { forceFix(); return;}			base.graphics.clear();			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, m_toolModeDetail.linealpha, false, "none");						var toX:Number;			var toY:Number;			if( m_shiftKey) {				// 水平か垂直か。				// 2点間の角度（atan）から求める				var rot:Number = Math.atan( base.mouseY / base.mouseX) * 180 / Math.PI;				if( -45 <= rot && rot <= 55) {					// 水平					toX = paintCon.mouseX - base.x;					toY = 0;				} else {					// 垂直					toX = 0;					toY = paintCon.mouseY - base.y;				}			} else {				toX = paintCon.mouseX - base.x;				toY = paintCon.mouseY - base.y;			}			base.graphics.lineTo( toX, toY);						// ペイントデータ保存2			base.setLineTo( toX, toY);						// 拡大縮小の時のためにサイズも保存しとく			base.setSize( base.getBounds( base).width, base.getBounds( base).height);								}		// 楕円スタート		function start_drawCircle() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;						var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_CIRCLE, paintCon.numChildren)));			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, m_toolModeDetail.linealpha, false, "none");			base.graphics.beginFill( m_toolModeDetail.fillcolor, m_toolModeDetail.fillalpha);			base.graphics.drawEllipse( 0, 0, 1, 1);			base.graphics.endFill();			base.alpha = 0.5;			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawCircle);			stage.addEventListener( MouseEvent.MOUSE_UP, onFix_drawCircle);			stage.addEventListener( MouseEvent.CLICK, onFix_drawCircle);			stage.addEventListener( MouseEvent.ROLL_OUT, onFix_drawCircle);			stage.addEventListener( Event.MOUSE_LEAVE, onFix_drawCircle);						// ペイントデータ保存1			base.setLineweight( m_toolModeDetail.lineweight);			base.setLinecolor( m_toolModeDetail.linecolor);			base.setLinealpha( m_toolModeDetail.linealpha);			base.setFillcolor( m_toolModeDetail.fillcolor);			base.setFillalpha( m_toolModeDetail.fillalpha);			base.setPosi( base.x, base.y);						m_lastPpStatus = "描画中";		}		// 楕円描き直し		function onMouseMove_drawCircle( e:*) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						if( ! isPaintable()) { forceFix(); return;}						base.graphics.clear();			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, m_toolModeDetail.linealpha, false, "none");			base.graphics.beginFill( m_toolModeDetail.fillcolor, m_toolModeDetail.fillalpha);			base.graphics.drawEllipse( 0, 0, paintCon.mouseX - base.x, paintCon.mouseY - base.y);			base.graphics.endFill();						// ペイントデータ保存2			base.setSize( paintCon.mouseX - base.x, paintCon.mouseY - base.y);		}		// 長方形スタート		function start_drawSquare() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_SQUARE, paintCon.numChildren)));			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, m_toolModeDetail.linealpha, false, "none");			base.graphics.beginFill( m_toolModeDetail.fillcolor, m_toolModeDetail.fillalpha);			base.graphics.drawRect( 0, 0, 1, 1);			base.graphics.endFill();			base.alpha = 0.5;			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawSquare);			stage.addEventListener( MouseEvent.MOUSE_UP, onFix_drawSquare);			stage.addEventListener( MouseEvent.CLICK, onFix_drawSquare);			stage.addEventListener( MouseEvent.ROLL_OUT, onFix_drawSquare);			stage.addEventListener( Event.MOUSE_LEAVE, onFix_drawSquare);						// ペイントデータ保存1			base.setLineweight( m_toolModeDetail.lineweight);			base.setLinecolor( m_toolModeDetail.linecolor);			base.setLinealpha( m_toolModeDetail.linealpha);			base.setFillcolor( m_toolModeDetail.fillcolor);			base.setFillalpha( m_toolModeDetail.fillalpha);			base.setPosi( base.x, base.y);						m_lastPpStatus = "描画中";		}		// 長方形描き直し		function onMouseMove_drawSquare( e:*) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						if( ! isPaintable()) { forceFix(); return;}						base.graphics.clear();			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, m_toolModeDetail.linealpha, false, "none");			base.graphics.beginFill( m_toolModeDetail.fillcolor, m_toolModeDetail.fillalpha);			base.graphics.drawRect( 0, 0, paintCon.mouseX - base.x, paintCon.mouseY - base.y);			base.graphics.endFill();						// ペイントデータ保存2			base.setSize( paintCon.mouseX - base.x, paintCon.mouseY - base.y);		}		// えんぴつスタート		function start_drawFreeLine() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_PENCIL, paintCon.numChildren)));			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, 1, false, "none");			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawFreeLine);			stage.addEventListener( MouseEvent.MOUSE_UP, onFix_drawFreeLine);			stage.addEventListener( MouseEvent.CLICK, onFix_drawFreeLine);			stage.addEventListener( MouseEvent.ROLL_OUT, onFix_drawFreeLine);			stage.addEventListener( Event.MOUSE_LEAVE, onFix_drawFreeLine);						// ペイントデータ保存1			base.setLineweight( m_toolModeDetail.lineweight);			base.setLinecolor( m_toolModeDetail.linecolor);			base.setPosi( paintCon.mouseX, paintCon.mouseY);						m_lastPpStatus = "描画中";		}		// えんぴつ描き足し		function onMouseMove_drawFreeLine( e:*) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						if( ! isPaintable()) { forceFix(); return;}						base.graphics.lineTo( base.mouseX, base.mouseY);						// ペイントデータ保存2			base.setLineTo( base.mouseX, base.mouseY);						// 拡大縮小の時のためにサイズも保存しとく			base.setSize( base.getBounds( base).width, base.getBounds( base).height);		}		// スムーズペンスタート		function start_drawSmoothLine() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.addChild( new PaintParts( WhiteboardContainer.TOOL_SMOOTH, paintCon.numChildren)));			base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, 1, false, "none");			base.x = paintCon.mouseX;			base.y = paintCon.mouseY;			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawSmoothLine);			stage.addEventListener( MouseEvent.MOUSE_UP, onFix_drawSmoothLine);			stage.addEventListener( MouseEvent.CLICK, onFix_drawSmoothLine);			stage.addEventListener( MouseEvent.ROLL_OUT, onFix_drawSmoothLine);			stage.addEventListener( Event.MOUSE_LEAVE, onFix_drawSmoothLine);						// 初期化			if( m_smoothLineToArr == null) m_smoothLineToArr = new Array();			else while( m_smoothLineToArr.length) m_smoothLineToArr.pop();			m_ttlSmoothLineTo = { _x:0, _y:0};			m_smoothSkipedCnt = 0;			m_smoothLineToArr.push({ _x:0, _y:0});						// ペイントデータ保存1			base.setLineweight( m_toolModeDetail.lineweight);			base.setLinecolor( m_toolModeDetail.linecolor);			base.setPosi( paintCon.mouseX, paintCon.mouseY);						m_lastPpStatus = "描画中";		}		// スムーズペン描き足し		function onMouseMove_drawSmoothLine( e:*) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						if( ! isPaintable()) { forceFix(); return;}						base.graphics.lineStyle( m_toolModeDetail.lineweight, m_toolModeDetail.linecolor, 1, false, "none");			//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", String( m_smoothSkipedCnt));							if( m_smoothSkipedCnt < SMOOTH_LEVEL) {				m_ttlSmoothLineTo._x += base.mouseX;				m_ttlSmoothLineTo._y += base.mouseY;				m_smoothSkipedCnt++;				return;			} else {								var aveX = m_ttlSmoothLineTo._x / SMOOTH_LEVEL;				var aveY = m_ttlSmoothLineTo._y / SMOOTH_LEVEL;								m_smoothLineToArr.push( { _x:aveX, _y:aveY});				base.setLineTo( aveX, aveY);								// リセット				m_ttlSmoothLineTo = { _x:0, _y:0};				m_smoothSkipedCnt = 0;			}			if( m_smoothLineToArr.length < 2 ) return;			// m_smoothLineToArr.length が2以上の時にのみ曲線を書き足していく						// 中間点（xc,xy）まで曲線を引く			var xc = ( m_smoothLineToArr[ m_smoothLineToArr.length-2]._x + m_smoothLineToArr[ m_smoothLineToArr.length-1]._x) / 2;			var yc = ( m_smoothLineToArr[ m_smoothLineToArr.length-2]._y + m_smoothLineToArr[ m_smoothLineToArr.length-1]._y) / 2;			base.graphics.curveTo( m_smoothLineToArr[ m_smoothLineToArr.length-2]._x,								   m_smoothLineToArr[ m_smoothLineToArr.length-2]._y,								   xc,yc);						// 拡大縮小の時のためにサイズも保存しとく			base.setSize( base.getBounds( base).width, base.getBounds( base).height);		}				// スムーズペンいったん終了		function onFix_drawSmoothLine( e:MouseEvent = null) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			if( paintCon.numChildren == 0) return;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawSmoothLine);			stage.removeEventListener( MouseEvent.CLICK, onFix_drawSmoothLine);			stage.removeEventListener( MouseEvent.ROLL_OUT, onFix_drawSmoothLine);			stage.removeEventListener( MouseEvent.MOUSE_UP, onFix_drawSmoothLine);			stage.removeEventListener( Event.MOUSE_LEAVE, onFix_drawSmoothLine);			onFix( base);		}				// お絵描きいったん終了		function onFix_drawFreeLine( e:MouseEvent = null) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			if( paintCon.numChildren == 0) return;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "お絵描きいったん終了" + String( base) + String( Math.random()));			if( base == null) return;			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawFreeLine);			stage.removeEventListener( MouseEvent.CLICK, onFix_drawFreeLine);			stage.removeEventListener( MouseEvent.ROLL_OUT, onFix_drawFreeLine);			stage.removeEventListener( MouseEvent.MOUSE_UP, onFix_drawFreeLine);			stage.removeEventListener( Event.MOUSE_LEAVE, onFix_drawFreeLine);			onFix( base);		}		function onFix_drawSquare( e:MouseEvent = null) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			if( paintCon.numChildren == 0) return;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;			base.alpha = 1;			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawSquare);			stage.removeEventListener( MouseEvent.CLICK, onFix_drawSquare);			stage.removeEventListener( MouseEvent.ROLL_OUT, onFix_drawSquare);			stage.removeEventListener( MouseEvent.MOUSE_UP, onFix_drawSquare);			stage.removeEventListener( Event.MOUSE_LEAVE, onFix_drawSquare);			onFix( base);		}		function onFix_drawLine( e:MouseEvent = null) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;						if( paintCon.numChildren == 0) return;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawLine);			stage.removeEventListener( MouseEvent.CLICK, onFix_drawLine);			stage.removeEventListener( MouseEvent.ROLL_OUT, onFix_drawLine);			stage.removeEventListener( MouseEvent.MOUSE_UP, onFix_drawLine);			stage.removeEventListener( Event.MOUSE_LEAVE, onFix_drawLine);			onFix( base);		}		function onFix_drawCircle( e:MouseEvent = null) {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;			if( paintCon.numChildren == 0) return;			var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;			base.alpha = 1;			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove_drawCircle);			stage.removeEventListener( MouseEvent.CLICK, onFix_drawCircle);			stage.removeEventListener( MouseEvent.ROLL_OUT, onFix_drawCircle);			stage.removeEventListener( MouseEvent.MOUSE_UP, onFix_drawCircle);			stage.removeEventListener( Event.MOUSE_LEAVE, onFix_drawCircle);			onFix( base);		}		// 一個のペイントパーツが生成〜FIXしたときに呼ばれる。WhiteBoardContainerに知らせてSO変更へ		function onFix( paintParts:PaintParts) {			if( WhiteboardContainer.WB_AUTHORIZED) {//alertDialog( "onFix:描画終了");				dispatchEvent( new PaintPartsEvent( PaintPartsEvent.ADDED, paintParts.getPaintPartsData()));			} else {				dispatchEvent( new Event( CHANGE_PP_LOCAL));			}			//dispatchEvent( new PaintPartsEvent( PaintPartsEvent.ADDED, paintParts.getPaintPartsData()));			m_lastPpStatus = "描画終了";						clearRedoPpArr();		}				/*public function allClear() {			// スライド自体の削除によって、ペイントパーツSharedObjectの中身が空になり、呼ばれる。alertDialog("allClear:スライド自体の削除によって、ペイントパーツSharedObjectの中身が空になり、呼ばれる");			clearAllPaintParts();			clearAllPaintParts_local();		}*/				// 自分もしくは誰かによってペイントパーツに変更（追加／変更／削除）があったとき		// WhiteboardContainer経由でWhiteboardからペイントパーツのSharedObjectの値変更時に呼ばれる		// すべてのペイントパーツはこの関数によって画面上に配置される		public function setPaintParts( ppdArr:Array) {//alertDialog("setPaintParts m_paintCon.numChildren:" + m_paintCon.numChildren);//alertDialog("setPaintParts ppdArr.length:" + ppdArr.length);			//var changed:Boolean = false;			if( !ppdArr || ppdArr.length == 0) {				clearAllPaintParts();			} else {							for each( var ppd in ppdArr) {										// 引数ppdのIDから変更対象のペイントパーツを探す					var targetPP:PaintParts = null;					for( var i:uint = 0; i < m_paintCon.numChildren; i++) {						var pp:PaintParts = m_paintCon.getChildAt( i) as PaintParts;						if( pp == null) continue;						var ppd_chk:PaintPartsData = pp.getPaintPartsData();						if( ppd_chk.id == ppd.id) {							targetPP = pp;							break;						}	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", i);					}	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "WbSlide:setPaintParts()targetPP:" + targetPP);															if( targetPP == null) {	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "WbSlide:setPaintParts() " + "新規追加: ");						// 新規追加						targetPP = new PaintParts( ppd.tool_name, ppd.depth, ppd.id, ppd.lastUpdateTime);						targetPP.setPaintPartsDataByObj( ppd);						//m_paintCon.addChildAt( targetPP, ppd.depth);						if( targetPP.visible) {							m_paintCon.addChild( targetPP);							//added = true;							//targetPP.addEventListener( PaintParts.REMOVED_PP, function( e:Event) { dispatchEvent( e);});						}						//changed = true;					} else if( isEqual( targetPP, ppd)) {						// 何もしない（自分自身によって追加／変更されたペイントパーツだった）	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "WbSlide:setPaintParts() " + "何もしない: " + String( targetPP.visible) + ">" + ppd.visible);	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:setPaintParts() " + "何もしない: " + String( ( targetPP.getPaintPartsData()).lastUpdateTime) + ">" + String( ppd.lastUpdateTime) + ":" + String( ppd.lastUpdateTime - ( targetPP.getPaintPartsData()).lastUpdateTime));					} else {						// 描画し直し	//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "WbSlide:setPaintParts() " + "描画し直し: " + String( ( targetPP.getPaintPartsData()).lastUpdateTime) + ">" + String( ppd.lastUpdateTime) + ":" + String( ppd.lastUpdateTime - ( targetPP.getPaintPartsData()).lastUpdateTime));												// 選択されていたら解除。						if( m_selectBox.isAdded( targetPP)) m_selectBox.removePaintParts( targetPP);												targetPP.setPaintPartsDataByObj( ppd);												//changed = true;					}				}			}						setPPSelectable();//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "WbSlide:" + changed);						dispatchEvent( new Event( CHANGE_PP));					}				function isEqual( pp:PaintParts, ppd2):Boolean {						if( pp.visible != ppd2.visible) return false;			var ppd1 = pp.getPaintPartsData();			if( ppd1.lastUpdateTime != ppd2.lastUpdateTime) return false;			return true;		}				// ペイントツールの選択可／不可の設定		function setPPSelectable() {						var b:Boolean = ( m_toolModeDetail != null && m_toolModeDetail.tool_name == WhiteboardContainer.TOOL_ARROW) ? true : false;						var i:uint;			var pp:PaintParts;			if( WhiteboardContainer.WB_AUTHORIZED) {				// WB権限がある場合は、選択できるのはm_paintCon上のペイントパーツのみ。（m_paintCon_localは非表示なので）				for( i = 0; i < m_paintCon.numChildren; i++) {					_setPPSelectable( m_paintCon.getChildAt( i) as PaintParts, b);				}				for( i = 0; i < m_paintCon_local.numChildren; i++) {					_setPPSelectable( m_paintCon_local.getChildAt( i) as PaintParts, false);				}			} else {				// WB権限が無い場合は、選択できるのはm_paintCon_local上のペイントパーツのみ。				for( i = 0; i < m_paintCon_local.numChildren; i++) {					_setPPSelectable( m_paintCon_local.getChildAt( i) as PaintParts, b);				}				for( i = 0; i < m_paintCon.numChildren; i++) {					_setPPSelectable( m_paintCon.getChildAt( i) as PaintParts, false);				}			}					}				function _setPPSelectable( pp:PaintParts, b:Boolean) {			if( pp == null) return;			if( b) {				// クリックされるのを監視。				pp.addEventListener( MouseEvent.CLICK, onClickPP);				// テキストの編集も監視				pp.addEventListener( PaintParts.TEXT_CHANGE_START, start_textChange);			} else {				pp.removeEventListener( MouseEvent.CLICK, onClickPP);				pp.removeEventListener( PaintParts.TEXT_CHANGE_START, start_textChange);			}		}		// ペイントパーツがクリックされたとき		function onClickPP( e:MouseEvent) {						var targetPP:PaintParts = e.target as PaintParts;			if( targetPP == null) targetPP = e.target.parent as PaintParts;			if( targetPP == null) Main.addErrMsg( "WbSlide:onClickPP() " + "fatal error");			// 選択or選択解除			if( ! m_shiftKey) {				// Shiftキーが押されていない場合//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onClickPP() " + "Shiftキーが押されていない");				if( m_selectBox.isAdded( targetPP)) {					// 全部選択解除//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onClickPP() " + "isAddedなので全部選択解除");					m_selectBox.removeAllPaintParts();				} else {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "WbSlide:onClickPP() " + "新規追加 とりあえず全部選択解除してから");					// とりあえず全部選択解除してから、ターゲットを追加					m_selectBox.removeAllPaintParts();					m_selectBox.addPaintParts( targetPP);				}			} else {				// Shiftキーが押されている場合				if( ! m_selectBox.isAdded( targetPP)) m_selectBox.addPaintParts( targetPP);				else m_selectBox.removePaintParts( targetPP);			}		}		function resetToolMode( toolModeDetail:ToolModeDetail) {			if( stage != null && m_pointer != null && stage.contains( m_pointer)) {				stage.removeChild( m_pointer);			}			m_toolModeDetail = toolModeDetail;			m_pointer = m_toolModeDetail.pointer;			m_pointer.name = "WbSlideCursor";						// カーソルの設定			if( m_pointer == null) showCursor();			else showPointer();						// 共有ポインターを表示するかどうか			m_toolModeDetail.removeEventListener( ToolModeDetail.LIVE_POINTER_STATUS_CHANGED, onLivePointerStatusChanged);			onLivePointerStatusChanged();			m_toolModeDetail.addEventListener( ToolModeDetail.LIVE_POINTER_STATUS_CHANGED, onLivePointerStatusChanged);		}		function onLivePointerStatusChanged( e:Event = null) {			if( m_toolModeDetail == null) return;			if( m_toolModeDetail.livePointerStatus) {				m_livePointerCon.showMyPointer();//alertDialog(" resetToolMode:ポインターを表示する");			} else {				m_livePointerCon.hideMyPointer();//alertDialog(" resetToolMode:ポインターを表示しない");			}		}		public function initSo( nc:NetConnection) {			m_livePointerCon.initSo( Main.CONF.CLASS_ID + "_liveP", nc); // 資料スライドとカメラスライドはoverrideしてる。			onLivePointerStatusChanged();		}				// LiveStatusManagerからWbCon、Whiteboard経由で呼ばれる。		public function changeJoinStatus( uid:String, flag:Boolean) {			m_livePointerCon.changeJoinStatus( uid, flag);		}				// ポインタ/カーソル表示切り替えのために表示領域を設定する		public function setViewArea( _x:Number, _y:Number, _w:Number, _h:Number) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "setViewArea:" + _x.toString() + "," + _y.toString() + "," + _w.toString()+ "," + _h.toString());			m_viewX = -( _x);			m_viewY = -( _y);			m_viewW = _w - 1;			m_viewH = _h - 1;		}				// WhiteboardContainer経由でWhiteboardからも呼ばれる		public function unsetBg() {		}				// WhiteboardContainer経由でWhiteboardからSharedObject（so_wbNow）の値変更時に呼ばれる		public function setBg() {		}				public function getBgtype() : String { return m_bgtype;}				function onEnterFrame( e) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "MouseMove:" + String( Math.random()));			if( stage == null) return;			if( m_pointer == null) return;			m_pointer.x = stage.mouseX;			m_pointer.y = stage.mouseY;//m_errMsg.text = String( WhiteboardContainer.CURSOR_BUSY);			if( WhiteboardContainer.CURSOR_BUSY) {				showCursor();//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "CURSOR_BUSY");			} else if( Main.POPUP_CONTAINER.isRollOveredExceptWbWin()) {				showCursor();			} else {				// マウスがスライド外に外れたらストップ				if( isPaintable() ) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "スライド内");					showPointer();									} else {					showCursor();										// マウスが画面の外に出ているので、ペイントパーツの描画を終了させる。					// マウスを押しっぱなし（描画の最中）で画面の外に出ると、					// 描画中のペイントパーツが共有オブジェクトに登録されずに					// 次のペイントパーツの描画がはじまっちゃったりして、					// 生徒画面と同期がとれなくなっちゃうから。					if( m_lastPpStatus != "描画前" && m_lastPpStatus != "描画終了") {												forceFix();												m_lastPpStatus = "描画終了";					}//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "OutOfSlide");				}			}					}		function forceFix() {			var paintCon = WhiteboardContainer.WB_AUTHORIZED ? m_paintCon : m_paintCon_local;						var base:PaintParts = PaintParts( paintCon.getChildAt( paintCon.numChildren - 1));			if( base == null) return;						switch( base.getPaintPartsData().tool_name) {				case WhiteboardContainer.TOOL_PENCIL:				case WhiteboardContainer.TOOL_ERASER:					onFix_drawFreeLine();					break;				case WhiteboardContainer.TOOL_SMOOTH:					onFix_drawSmoothLine();					break;				case WhiteboardContainer.TOOL_ZOOMIN:					//zoom( true);					break;				case WhiteboardContainer.TOOL_ZOOMOUT:					//zoom( false);					break;				case WhiteboardContainer.TOOL_LINE:					onFix_drawLine();					break;				case WhiteboardContainer.TOOL_SQUARE:					onFix_drawSquare();					break;				case WhiteboardContainer.TOOL_CIRCLE:					onFix_drawCircle();					break;			}						clearRedoPpArr();		}				function showPointer() : void {			if( m_toolModeDetail.tool_name == WhiteboardContainer.TOOL_ARROW) return;						// カーソルを消す			Main.MOUSE_MANAGER.showMouse( false, this);						if( stage == null) return;			if( m_pointer == null) return;			//if( stage.getChildByName( "PartitionCursor") != null) return;						if( ! stage.contains( m_pointer)) {				stage.addChild( m_pointer);			}		}		function showCursor() : void {			if( stage == null) return;			//if( stage.getChildByName( "PartitionCursor") != null) return;						// カーソルを表示			Main.MOUSE_MANAGER.showMouse( true, this);						if( m_pointer == null) return;			if( stage.contains( m_pointer)) {				stage.removeChild( m_pointer);			}		}		public function getScale() : Number {			return m_container.scaleX;		}				// ToolchipContainerのscaleコンボボックス変更により呼ばれる		public function setScale( scale:Number) : void {			m_container.scaleY = scale;			if( m_container.scaleY > MAX_SCALE) m_container.scaleY = MAX_SCALE;			if( m_container.scaleY < MIN_SCALE) m_container.scaleY = MIN_SCALE;			m_container.scaleX = m_container.scaleY;									dispatchEvent( new Event( CHANGE_SIZE_BY_COMBO));		}		function alertDialog( str) {			Main.addErrMsg( String( str));		}				// WhiteboardContainer：ホワイトボード権限が無い場合、全クリアボタンクリックでclearAllPaintParts()から呼ばれる。		// WhiteboardContainer：clearAllPaintParts_local()からWhiteboard経由で呼ばれる		public function clearAllPaintParts_local() : void {				m_selectBox.removeAllPaintParts();			while( m_paintCon_local.numChildren) {				m_paintCon_local.removeChildAt( 0);			}		}		// WhiteboardContainer：ホワイトボード権限がある場合、全クリアボタンクリックでclearAllPaintParts()から呼ばれる。		// WhiteboardContainer：clearAllPaintParts()からWhiteboard経由で呼ばれる		public function clearAllPaintParts() : void {				m_selectBox.removeAllPaintParts();			while( m_paintCon.numChildren) {				m_paintCon.removeChildAt( 0);			}		}	}}