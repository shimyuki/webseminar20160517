package window.whiteboard.slide {	import flash.display.*;	import window.whiteboard.*;	import flash.text.*;	import flash.events.Event;	import flash.events.TextEvent;	import flash.events.FocusEvent;	import flash.events.MouseEvent;		public class PaintParts extends Sprite {		static public const TEXT_FIXED:String = "TEXT_FIXED";		static public const TEXT_CHANGE_START:String = "TEXT_CHANGE_START";		static public const TEXT_CHANGED:String = "TEXT_CHANGED";		//static public const REMOVED_PP:String = "REMOVED_PP";				public var id:String;		private var m_paintPartsData:PaintPartsData;		//private var m_selected:Boolean = false;		private var m_boundsBox:PaintPartsBoundsBox;		private var m_text:TextField;		private var m_text_dispach_type:String = TEXT_FIXED;				public function PaintParts( tool_name:String, depth:uint, _id:String = "", _lastUpdateTime:Number = 0) {			m_paintPartsData = new PaintPartsData( tool_name, depth, _id, _lastUpdateTime);			id = m_paintPartsData.id;			m_boundsBox = PaintPartsBoundsBox( addChild( new PaintPartsBoundsBox()));			m_boundsBox.visible = false;			m_text = new TextField();			m_text.selectable = false;						// テキストパーツだった場合、ダブルクリックで再編集可能にする			m_text.doubleClickEnabled = true;			m_text.addEventListener( Event.ADDED_TO_STAGE,				function( e:Event) {					addEventListener( MouseEvent.DOUBLE_CLICK, onDoubleClickText);				});			m_text.addEventListener( Event.REMOVED_FROM_STAGE,				function( e:Event) {					removeEventListener( MouseEvent.DOUBLE_CLICK, onDoubleClickText);				});		}		function onDoubleClickText( e:MouseEvent) {			if( WhiteboardContainer.WB_AUTHORIZED) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "PaintParts:onDoubleClickText()");				dispatchEvent( new Event( TEXT_CHANGE_START));				m_text_dispach_type = TEXT_CHANGED;				setTextField();			}		}				public function getPaintPartsData() : PaintPartsData { return m_paintPartsData;}				public function setVisible( b:Boolean) {			m_paintPartsData.visible = visible = b;		}		public function removeIfUnvisible() {			if( !visible && parent && parent.contains( this)) {				parent.removeChild( this);			}		}		public function setLineweight( val:Number) { m_paintPartsData.lineweight = val;}		public function setLinecolor( val:Number) { m_paintPartsData.linecolor = val;}		public function setLinealpha( val:Number) { m_paintPartsData.linealpha = val;}		public function setFillcolor( val:Number) { m_paintPartsData.fillcolor = val;}		public function setFillalpha( val:Number) { m_paintPartsData.fillalpha = val;}		public function setPosi( _x:Number, _y:Number) { m_paintPartsData.posi_x = x = _x; m_paintPartsData.posi_y = y = _y;}		//public function setMoveTo( _x:Number, _y:Number) { m_paintPartsData.moveTo_x = _x; m_paintPartsData.moveTo_y = _y;}		public function setSize( _w:Number, _h:Number) { m_paintPartsData.size_w = _w; m_paintPartsData.size_h = _h;}		public function setLineTo( _x:Number, _y:Number) {			m_paintPartsData.lineTo_x.push( _x);			m_paintPartsData.lineTo_y.push( _y);		}		public function setFontname( val:String) { m_paintPartsData.fontname = val;}		public function setFontsize( val:Number) { m_paintPartsData.fontsize = val;}		public function setFontbold( b:Boolean) { m_paintPartsData.fontbold = b;}		public function setText( val:String) { m_paintPartsData.text = val;}		public function setScale( _sx:Number, _sy:Number) { m_paintPartsData.scaleX = scaleX = _sx; m_paintPartsData.scaleY = scaleY= _sy;}		public function setUpdateTime( val:Number = 0):Number {			if( val == 0) m_paintPartsData.lastUpdateTime = ( new Date()).getTime();			else m_paintPartsData.lastUpdateTime = val;			return m_paintPartsData.lastUpdateTime;		}				// WbSlide：addTextField()から呼ばれる。（手動でクリックして追加される時のみ）		public function setTextField() {			if( ! contains( m_text)) addChild( m_text);			m_text.selectable = true;			m_text.type = TextFieldType.INPUT;			m_text.defaultTextFormat = new TextFormat( m_paintPartsData.fontname, m_paintPartsData.fontsize, m_paintPartsData.fillcolor, m_paintPartsData.fontbold);			m_text.multiline = true;			m_text.text = m_paintPartsData.text;			m_text.autoSize = TextFieldAutoSize.LEFT;			m_text.addEventListener( FocusEvent.FOCUS_OUT, fix); // Tabによりフォーカスがはずれることもあるので必要。			if( stage) stage.focus = m_text;		}				// WbSlide：start_inputText()からステージがクリック時に呼ばれる。（テキストを手動で編集中の時のみ）		public function setTextFieldFocusOut() {			m_text.removeEventListener( FocusEvent.FOCUS_OUT, fix); // 監視しているままだと何度も呼ばれるので、いったん解除			fix();		}						// ステージクリック時か、Tab押下時に呼ばれる		function fix( e:* = null) {			if( e == null) {				// ステージクリックで呼ばれた場合//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "PaintParts:fix() フォーカス1:" + String( stage.focus));					stage.focus = null;//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "PaintParts:fix() フォーカス2:" + String( stage.focus));				}			if( stage && e != null) {				// Tab押下でFocusEvent.FOCUS_OUTをキャッチしたことにより呼ばれた場合				m_text.removeEventListener( FocusEvent.FOCUS_OUT, fix);			}			m_text.type = TextFieldType.DYNAMIC;			m_text.selectable = false;			m_paintPartsData.text = m_text.text;			m_paintPartsData.lastUpdateTime = ( new Date()).getTime();						// 拡大縮小の時のためにサイズも保存しとく			m_paintPartsData.size_w = m_text.width;			m_paintPartsData.size_h = m_text.height;			dispatchEvent( new Event( m_text_dispach_type)); // WbSlideに知らせる		}				// WbSlide：setPaintParts()で、新規追加or描画し直しのときに呼ばれる		public function setPaintPartsDataByObj( ppd:Object/*:PaintPartsData*/) :Boolean {						m_paintPartsData.tool_name = ppd.tool_name;			m_paintPartsData.depth = ppd.depth;			setVisible( ppd.visible);			setLineweight( ppd.lineweight);			setLinecolor( ppd.linecolor);			setLinealpha( ppd.linealpha);			setFillcolor( ppd.fillcolor);			setFillalpha( ppd.fillalpha);			setPosi( ppd.posi_x, ppd.posi_y);			//setMoveTo( ppd.moveTo_x, ppd.moveTo_y);			setSize( ppd.size_w, ppd.size_h);			setFontname( ppd.fontname);			setFontsize( ppd.fontsize);			setFontbold( ppd.fontbold);			setText( ppd.text);			setScale( ppd.scaleX, ppd.scaleY);						// 配列を削除して入れ直し			while( m_paintPartsData.lineTo_x.length) m_paintPartsData.lineTo_x.pop();			while( m_paintPartsData.lineTo_y.length) m_paintPartsData.lineTo_y.pop();						var lineTo_x:Array = ppd.lineTo_x as Array;			var lineTo_y:Array = ppd.lineTo_y as Array;			if( lineTo_x != null && lineTo_y != null) {				for( var k = 0; k < lineTo_x.length; k++) {					setLineTo( lineTo_x[k], lineTo_y[k]);				}			}			changeMyself();//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "PaintParts:setPaintPartsDataByObj() " + "changeMyself stop");				return true;		}				// ペイントパーツデータの通り自分自身を描画し直す		function changeMyself() {			// いったん全部削除。			graphics.clear();			if( contains( m_text)) removeChild( m_text);						var i:uint;			switch( m_paintPartsData.tool_name) {				case WhiteboardContainer.TOOL_ARROW:					break;				case WhiteboardContainer.TOOL_PENCIL:					graphics.lineStyle( m_paintPartsData.lineweight, m_paintPartsData.linecolor, 1, false, "none");					//graphics.moveTo( m_paintPartsData.moveTo_x, m_paintPartsData.moveTo_y);					for( i = 0; i < m_paintPartsData.lineTo_x.length; i++) {						graphics.lineTo( m_paintPartsData.lineTo_x[i], m_paintPartsData.lineTo_y[i]);					}					break;				case WhiteboardContainer.TOOL_SMOOTH:					graphics.lineStyle( m_paintPartsData.lineweight, m_paintPartsData.linecolor, 1, false, "none");					for( i = 1; i < m_paintPartsData.lineTo_x.length; i++) {						var xc = ( m_paintPartsData.lineTo_x[i-1] + m_paintPartsData.lineTo_x[i]) / 2;						var yc = ( m_paintPartsData.lineTo_y[i-1] + m_paintPartsData.lineTo_y[i]) / 2;						graphics.curveTo( m_paintPartsData.lineTo_x[i-1], m_paintPartsData.lineTo_y[i-1], xc, yc);					}					break;				case WhiteboardContainer.TOOL_ZOOMIN:					break;				case WhiteboardContainer.TOOL_ZOOMOUT:					break;				case WhiteboardContainer.TOOL_LINE:					// 直線					graphics.lineStyle( m_paintPartsData.lineweight, m_paintPartsData.linecolor, 1, false, "none");					graphics.lineTo( m_paintPartsData.lineTo_x[m_paintPartsData.lineTo_x.length - 1], m_paintPartsData.lineTo_y[m_paintPartsData.lineTo_y.length - 1]);					break;				case WhiteboardContainer.TOOL_SQUARE:					// 長方形					graphics.lineStyle( m_paintPartsData.lineweight, m_paintPartsData.linecolor, m_paintPartsData.linealpha, false, "none");					graphics.beginFill( m_paintPartsData.fillcolor, m_paintPartsData.fillalpha);					graphics.drawRect( 0, 0, m_paintPartsData.size_w, m_paintPartsData.size_h);					graphics.endFill();					break;				case WhiteboardContainer.TOOL_CIRCLE:					// 楕円					graphics.lineStyle( m_paintPartsData.lineweight, m_paintPartsData.linecolor, m_paintPartsData.linealpha, false, "none");					graphics.beginFill( m_paintPartsData.fillcolor, m_paintPartsData.fillalpha);					graphics.drawEllipse( 0, 0, m_paintPartsData.size_w, m_paintPartsData.size_h);					graphics.endFill();					break;				case WhiteboardContainer.TOOL_TEXT:					// テキスト					addChild( m_text);					/*if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "PaintParts:changeMyself() " +  					   m_paintPartsData.fontname + ", " +					  m_paintPartsData.fontsize + ", " +					  m_paintPartsData.fillcolor + ", " +					  m_paintPartsData.fontbold);*/					m_text.defaultTextFormat = new TextFormat( m_paintPartsData.fontname,															  m_paintPartsData.fontsize,															  m_paintPartsData.fillcolor,															  m_paintPartsData.fontbold);					m_text.multiline = true;					m_text.text = m_paintPartsData.text;					m_text.autoSize = TextFieldAutoSize.LEFT;									default: break;			}											}				// SelectBoxで選択されたときに呼ばれる		public function setBoundsBox( b:Boolean) {			m_boundsBox.visible = b;			if( b) m_boundsBox.set();		}			}}