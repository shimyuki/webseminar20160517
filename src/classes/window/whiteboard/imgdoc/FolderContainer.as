package window.whiteboard.imgdoc {	import flash.display.*;	import flash.geom.*;	import common.*;	import window.*;	import window.whiteboard.*;	import flash.text.*;	import flash.events.*;	import flash.net.*;	import flash.ui.Keyboard;	import flash.utils.*;	import caurina.transitions.*;	import common.AlertManager;	// サムネイル一覧コンテナ	public class FolderContainer extends Sprite {		static public const XML_LOAD_COMPLETE = "Thumbnails XML LOAD COMPLETE";		static public const XML_LOAD_ERROR = "Thumbnails XML LOAD ERROR";		static public const THU_LOAD_ERROR = "ERROR: can't load image";		static public const REPLACED = "FolderContainer REPLACED";		//static public const RESORTED = "Thumbnails RESORTED";		static public const INIT_LISTTYPE = ListTypeBtn.TEXT_CLICKED;		//static public const INIT_LISTTYPE = ListTypeBtn.THUMB_CLICKED;		private const MSG_CONFIRM_ALL_DELETE = ImgdocContainer.MSG_CONFIRM_ALL_DELETE;		private const MSG_ADD_DIR_ERROR:String = Main.LANG.getParam( "新規フォルダ作成に失敗しました");		private const MSG_ALLREADY_EXIST_ERROT:String = Main.LANG.getParam( "そのフォルダは既に存在しています");		private const MSG_ADD_COMPLETE:String = Main.LANG.getParam( "追加完了");		private const THU_SIZE = 60;		private var W:Number = 100;		private var m_docErrArr:Array; // 画像読み込みに失敗したサムネイル		private var m_listtype:String = INIT_LISTTYPE;		private var m_topDir:Dir_top = null;		private var m_selectedDirArr:Array = null; // 選択中		private var m_dragDir:DragingDir;		private var m_dragDx:Number;		private var m_dragDy:Number;		private var m_plusedDir:Dir;		private var so_sortId:SharedObject = null;		private var m_shiftKey:Boolean = false; // SHIFTキーが押されている状態か、監視		private var m_ctrlKey:Boolean = false; // CRLキーが押されている状態か、監視		private var m_selectPlusPanel:SelectPlusPanel;		private var m_spreadDir:Dir = null; // 展開しているDir（サムネイル表示の場合に使う。テキスト表示の場合はm_topDir。）				public function FolderContainer() {			//m_docArr = new Array();			m_docErrArr = new Array();			m_selectedDirArr = new Array();			m_selectPlusPanel = new SelectPlusPanel();			m_selectPlusPanel.addEventListener( "addFile",						function( e:Event){							if( contains( m_selectPlusPanel)) removeChild( m_selectPlusPanel);							dispatchEvent( new DirEvent( DirEvent.PLUS_CLICKED, m_plusedDir));						});			m_selectPlusPanel.addEventListener( "addDir", startAddDir);						m_selectPlusPanel.addEventListener( Event.ADDED_TO_STAGE,							 function( e:Event) {									//stage.addEventListener( MouseEvent.CLICK, onStageClicked);							 });						addEventListener( Event.ADDED_TO_STAGE,							 function( e:Event) {								m_shiftKey = false;								m_ctrlKey = false;								stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyboardDown);								stage.addEventListener( KeyboardEvent.KEY_UP, onKeyboardUp);							 });			addEventListener( Event.REMOVED_FROM_STAGE,							 function( e:Event) {								m_shiftKey = false;								m_ctrlKey = false;								stage.removeEventListener( MouseEvent.CLICK, onStageClicked);							 });		}				// 見える部分にあるDocだけサムネイル表示（読み込み）		public function loadImageWithin( maskRectOfStage:Rectangle) {						if( m_listtype == ListTypeBtn.TEXT_CLICKED) return;			if( m_spreadDir == null) return;//Main.addDebugMsg( "-------------FolderContainer loadImageWithin()" + m_spreadDir.name);						for( var i:uint = 0; i < m_spreadDir.numChildren; i++) {				var doc:Doc = m_spreadDir.getChildAt( i) as Doc;				if( doc == null) continue;				if( doc.isThumbLoadStarted()) continue;								var pt_local:Point = new Point( doc.x, doc.y);				var pt_global:Point = localToGlobal( pt_local);//trace( doc.name, maskRectOfStage.top, pt_global.y, maskRectOfStage.bottom);				if( maskRectOfStage.top < pt_global.y + doc.getViewHeight() && pt_global.y < maskRectOfStage.bottom) {					doc.startLoadImage();				}			}					}				function onStageClicked( e:MouseEvent) {			// セレクトパネル領域以外をクリックされたらセレクトパネルをremoveする			if( contains( m_selectPlusPanel)) {				var bounds:Rectangle = m_selectPlusPanel.getBounds( stage);//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "onStageClicked: " + bounds.x + " < " + stage.mouseX + " < " +  String( bounds.x + bounds.width));				if( ! ( bounds.x < stage.mouseX && stage.mouseX < bounds.x + bounds.width				   && bounds.y < stage.mouseY && stage.mouseY < bounds.y + bounds.height)) {					removeChild( m_selectPlusPanel);				}			}			stage.removeEventListener( MouseEvent.CLICK, onStageClicked);		}		function onKeyboardDown( e:KeyboardEvent):void {//alertDialog( e.shiftKey + ":  " + e.keyCode + "<=>" + Keyboard.SHIFT);			if( e.shiftKey) m_shiftKey = true;			if( e.ctrlKey) m_ctrlKey = true;		}		function onKeyboardUp( e:KeyboardEvent):void {//alertDialog( e.keyCode + "<=>" + Keyboard.SHIFT);			if( e.keyCode == Keyboard.SHIFT) m_shiftKey = false;			if( e.keyCode == Keyboard.CONTROL) m_ctrlKey = false;		}						public function init() : String {			if( m_topDir == null) {				m_topDir = Dir_top( addChild( new Dir_top( "", 0)));								m_topDir.addEventListener( DirEvent.CLICKED, onDirClicked);				m_topDir.addEventListener( DirEvent.DOUBLE_CLICKED, onDirDoubleClicked);				m_topDir.addEventListener( DirEvent.START_DRAG, onDirStartDrag);				//m_topDir.addEventListener( DirEvent.STOP_DRAG, onDirStopDrag);				m_topDir.addEventListener( DirEvent.PLUS_CLICKED, onDirPlusClicked);				m_topDir.addEventListener( DirEvent.MINUS_CLICKED, onDirMinusClicked);												m_dragDir = new DragingDir();								m_spreadDir = m_topDir;			} else {				deleteDir( m_topDir, false, false);			}						// 追加済みの資料ファイル読み込み			return loadDocList();			 		}				// ImgdocContainer:onMinusBtnClick()から呼ばれる。		// 選択されているDirを削除		public function deleteSelectedDir() {			var selectedDirArr:Array = m_topDir.getSelectedChildren();			for each( var dir in selectedDirArr) {				deleteDir( dir);				// スリープ				wait( 250);			}		}		// ImgdocContainer:onAllMinusBtnClick()から呼ばれる。		// 全部削除		public function deleteAll() {			deleteDir( m_topDir);		}		function onDirMinusClicked( e:DirEvent) {			dispatchEvent( new DirEvent( DirEvent.MINUS_CLICKED, e.dir));			deleteDir( e.dir);		}				// deleteFromServer:サーバーからも削除するか		// （既存ファイルの上書きアップロードだった場合はサーバーからは削除しない）		function deleteDir( targetDir:Dir, deleteFromServer:Boolean = true, needsConfirm:Boolean = true) {			//trace(targetDir,m_topDir );//Main.addDebugMsg( "FolderCon:deleteDir(" + targetDir.getPath() + "," + String( deleteFromServer) + "," + String( needsConfirm) + ")");			var deletePath = targetDir.getPath(); // removeChildする前にパスをキープしておく。			targetDir.removeListenChildren();						if( targetDir == m_topDir) {				if( needsConfirm) {										AlertManager.createAlert( this, MSG_CONFIRM_ALL_DELETE										 ,"",[Main.LANG.getParam( "はい"),Main.LANG.getParam( "いいえ")],										 function( e:Event){											 if( e.target.name == Main.LANG.getParam( "はい")) {												 for( var i = 0; i < m_topDir.numChildren; i++) {													var dir:Dir = m_topDir.getChildAt( i) as Dir;													if( dir != null) {														m_topDir.removeChild( dir);														i--;													}												}												if( deleteFromServer) _deleteFromServer( m_topDir.getPath());											 }										 });					return; // ここでreturnしておかないと、「いいえ」が選択された場合もdeleteFromServer()を実行してしまう。								} else {					for( var i = 0; i < m_topDir.numChildren; i++) {						var dir:Dir = m_topDir.getChildAt( i) as Dir;						if( dir != null) {							m_topDir.removeChild( dir);							i--;						}					}				}/*				var ret = true;				if( needsConfirm && ExternalInterface.available) ret = ExternalInterface.call( "flashFunc_comfirm", MSG_CONFIRM_ALL_DELETE);				if( ret) {					for( var i = 0; i < m_topDir.numChildren; i++) {						var dir:Dir = m_topDir.getChildAt( i) as Dir;						if( dir != null) {							m_topDir.removeChild( dir);							i--;						}					}				}*/			} else {				if( targetDir.parent) targetDir.parent.removeChild( targetDir);								if( targetDir as Doc != null) {					targetDir.removeEventListener( DocEvent.SELECTED, onDocSelected);					//targetDir.removeEventListener( DocEvent.REMOVED, reDispatchDocEvent); // これはremoveしない！					targetDir.removeEventListener( DocEvent.ADDED, reDispatchDocEvent);					Doc( targetDir).onRemoved();				}			}			replace();									if( ! deleteFromServer) return;						_deleteFromServer( deletePath);		}		function _deleteFromServer( deletePath:String) {			// システムに通知する（システム側で失敗しても気にしない）			var path:String = Main.CONF.getParam( "UPLOAD_URL");			if( path == LoadConf.NOTFOUND) {				alertDialog( Main.LANG.getParam( "UPLOAD_URLが設定されていないためファイルを送信できませんでした"));				return;			}						var urlVar:URLVariables = new URLVariables();			var req:URLRequest = new URLRequest( path);			req.method = URLRequestMethod.POST;			urlVar.do_mode = "delete-doc";			urlVar.class_id = Main.CONF.CLASS_ID;			urlVar.deletePath = deletePath;									req.data = urlVar;						var ldr:URLLoader = new URLLoader();			try {				ldr.load( req);			} catch( e:Error){			}					}				function onDirPlusClicked( e:DirEvent) {			m_selectPlusPanel.clearDirName();						m_topDir.offAllChildren( e.dir);			e.dir.select( true);						addChild( m_selectPlusPanel);			m_plusedDir = e.dir;			m_selectPlusPanel.x = 10;			m_selectPlusPanel.y = e.dir.getRect( this).y + e.dir.getViewHeight_single();						stage.removeEventListener( MouseEvent.CLICK, onStageClicked);			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove4hideSelectPanel);			function onMouseMove4hideSelectPanel( e:*) {				stage.addEventListener( MouseEvent.CLICK, onStageClicked);				stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove4hideSelectPanel);			}		}		function startAddDir( e:Event) {						var newDir4check = m_plusedDir != m_topDir ?								m_plusedDir.getPath() + "/" + m_selectPlusPanel.getDirName()								: m_selectPlusPanel.getDirName();											if( m_topDir.hasDir( newDir4check)) {				errDialog( MSG_ALLREADY_EXIST_ERROT);				return;			}											if( contains( m_selectPlusPanel)) removeChild( m_selectPlusPanel);						// システムに通知し、成功したらFlash側でもaddDirする			var path:String = Main.CONF.getParam( "UPLOAD_URL");			if( path == LoadConf.NOTFOUND) {				alertDialog( Main.LANG.getParam( "UPLOAD_URLが設定されていないためファイルを送信できませんでした"));				return;			}			var req:URLRequest = new URLRequest();			req.url = path;			req.method = URLRequestMethod.POST;			var urlVar:URLVariables = new URLVariables();			urlVar.do_mode = "mkdir";			urlVar.class_id = Main.CONF.CLASS_ID;			urlVar.newDir = m_plusedDir != m_topDir ?								m_plusedDir.getPath() + "/" + m_selectPlusPanel.getDirName() + "/"								: m_selectPlusPanel.getDirName() + "/";						req.data = urlVar;//alertDialog( urlVar.newDir);						var ldr:URLLoader = new URLLoader();			ldr.addEventListener( Event.COMPLETE, onDirUploaded);			ldr.addEventListener( IOErrorEvent.IO_ERROR, function(e:*) { errDialog( MSG_ADD_DIR_ERROR + "\nIO_ERROR");});			ldr.addEventListener( SecurityErrorEvent.SECURITY_ERROR, function(e:*) { errDialog( MSG_ADD_DIR_ERROR+ "\SECURITY_ERROR");});				try {				ldr.load( req);			} catch( e:Error){				errDialog( MSG_ADD_DIR_ERROR);			}		}		function onDirUploaded( e:Event) {			var ldr:URLLoader = URLLoader ( e.target);//alertDialog(ldr.data);			try {				// httpで始まりスラッシュで終わる文字列が返ってきたら、成功。				if( String( ldr.data).match(/^http.*\/$/)) {					m_topDir.addDir( ldr.data);					replace();				} else {					errDialog( MSG_ADD_DIR_ERROR + "\n" + String( ldr.data));				}			} catch( e:Error) {				errDialog( MSG_ADD_DIR_ERROR);			}//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "onLoadDocList():" + e.type);					}		function errDialog( msg:String) {			Main.addErrMsg( msg);		}		function onDirDoubleClicked( e:DirEvent) {			if( m_listtype != ListTypeBtn.THUMB_CLICKED) return;//trace("============onDirDoubleClicked:");						m_spreadDir = e.dir;			replace();		}		function onDirClicked( e:DirEvent) {//trace("============onDirClicked:");//trace(e.dir.getName());			var dir_clicked:Dir = Dir( e.dir);			if( m_shiftKey || m_ctrlKey) {				// シフトキーが押されている			} else {				m_topDir.offAllChildren( e.dir);				m_selectedDirArr = [];				if( dir_clicked.isSelected()) dir_clicked.open( ! dir_clicked.isOpened());			}						dir_clicked.select( true);			m_selectedDirArr.push( dir_clicked);//trace( "onDirClicked", dir_clicked);						onDirStopDrag_rightaway();						if( contains( m_selectPlusPanel)) removeChild( m_selectPlusPanel);		}		function onDirStartDrag( e:DirEvent) {//trace("============onDirStartDrag:", e.dir.isSelected());			onDirStopDrag_rightaway();			//if( ! e.dir.isSelected()) return;						// 選択されていない状態のDirをドラッグし始めたら、このDirのみを選択状態にして、			// 他の選択されていたDir（もしあれば）を非選択にする			if( ! e.dir.isSelected()) {				m_topDir.offAllChildren( e.dir);				m_selectedDirArr = [];				e.dir.select( true);				m_selectedDirArr.push( e.dir);			}						addChild( m_dragDir);			m_dragDir.setCacheAndStartPosi( m_selectedDirArr, this);			m_dragDx = mouseX - m_dragDir.getStartX();			m_dragDy = mouseY - m_dragDir.getStartY();						stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMOVE);			stage.addEventListener( MouseEvent.MOUSE_UP, onDirStopDrag);						// 各DIRに、マウスが自分の上に乗っているか、そして引数のDIR(m_targetDir)との関係から			// ドロップされたときにどうするかの判定を行わせる の開始			m_topDir.startWatchHovered( m_selectedDirArr);		}		function onMouseMOVE( e:MouseEvent) {			m_dragDir.x = mouseX - m_dragDx;			m_dragDir.y = mouseY - m_dragDy;			var imgdocCon:ImgdocContainer = parent.parent as ImgdocContainer;			if( imgdocCon == null) {//trace( "FolderContainer:parent.parent" + parent.parent +"is not ImgdocContainer object");//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "FolderContainer:parent.parent is not ImgdocContainer object");				onDirStopDrag_rightaway();			}//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", imgdocCon.mouseX + "," + imgdocCon.mouseY);			if( imgdocCon.mouseX < 0 || imgdocCon.getViewWidth() < imgdocCon.mouseX ||			   imgdocCon.mouseY < 0 || imgdocCon.getViewHeight() < imgdocCon.mouseY) onDirStopDrag();		}		function onDirStopDrag_rightaway() {			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMOVE);			stage.removeEventListener( MouseEvent.MOUSE_UP, onDirStopDrag);			Tweener.removeTweens( m_dragDir);			if( contains( m_dragDir)) removeChild( m_dragDir);						m_topDir.stopWatchHovered();		}		function onDirStopDrag( e:MouseEvent = null) {			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMOVE);			stage.removeEventListener( MouseEvent.MOUSE_UP, onDirStopDrag);						var moved:Boolean = false;			if( e != null) {				// マウスアップによってドラッグが任意終了したタイミング				var dir_hovered:Dir = m_topDir.getHoveredDir();//trace( dir_hovered);				if( dir_hovered != null) {										// PHPのPOST用（移動前のパス配列）					var prevPathArr:Array = new Array();																	// 移動予定のdir( m_selectedDirArr)について、FolderContainer上のXY位置から					// ソートID配列をキープしておく（実際にADDが成功したら、このソートIDを多少加工して適用する）					var selectedDirSortArr:Array = getSelectedDirSortArrByPosi();													if( dir_hovered as Doc == null) {						// ドラッグ先がフォルダの場合												var err:Boolean = false;						var dir:Dir;						var i:uint;																							switch( dir_hovered.getHoveredStatus()) {														case Dir.HOVERED_STATUS_ON_UNDER:							if( ! dir_hovered.isOpened()) {								// 閉じてるフォルダの下								// ----------------------------------------------------------------------------------								// ドラッグ先の１個上のフォルダにADDし、ソート順をドラッグ先のフォルダの一個後にする								// ----------------------------------------------------------------------------------								if( dir_hovered.parent as Dir == null) break;								// ドラッグ先親フォルダ内のchildrenについて、現状のXY位置からソートIDを振り直しておく								Dir( dir_hovered.parent).setChildSortIdByPosi( 0);																for( i = 0; i < m_selectedDirArr.length; i++) {									prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());									try {										dir_hovered.parent.addChild( m_selectedDirArr[ i]);										Dir( m_selectedDirArr[i]).sortId =											Dir( dir_hovered).sortId												+ ( selectedDirSortArr[ i] + 1) / ( selectedDirSortArr[ m_selectedDirArr.length-1] + 2);										moved = true;									} catch( e) {										// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる										prevPathArr.pop();									}								}																moveDoc( Dir( dir_hovered.parent), prevPathArr);															} else {								// 開いているフォルダのすぐ下に								// ----------------------------------------------------------------------------------								// ドラッグ先のフォルダにADDし、ソート順をドラッグ先のフォルダ内の最初に								// ----------------------------------------------------------------------------------																// ドラッグ先フォルダ内のchildrenについて、現状のXY位置からソートIDを振り直しておく								dir_hovered.setChildSortIdByPosi( selectedDirSortArr.length + 1);																for( i = 0; i < m_selectedDirArr.length; i++) {									prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());									try {										dir_hovered.addChild( m_selectedDirArr[ i]);										Dir( m_selectedDirArr[i]).sortId = selectedDirSortArr[ i];										moved = true;									} catch( e) {										// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる										prevPathArr.pop();									}								}								moveDoc( dir_hovered, prevPathArr);							}							break;							case Dir.HOVERED_STATUS_ON:							// ----------------------------------------------------------------------------------							// ドラッグ先のフォルダにADDし、ソート順をドラッグ先のフォルダ内のラストに							// ----------------------------------------------------------------------------------							// ドラッグ先フォルダ内のchildrenについて、現状のXY位置からソートIDを振り直しておく							var lastSortId:uint = dir_hovered.setChildSortIdByPosi( 0);														for( i = 0; i < m_selectedDirArr.length; i++) {								//if( dir_hovered.contains( m_selectedDirArr[ i])) break; // 追加済みならキャンセル								if( m_selectedDirArr[ i].parent == dir_hovered) break; // 追加済みならキャンセル								prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());								try {									dir_hovered.addChild( m_selectedDirArr[ i]);									Dir( m_selectedDirArr[i]).sortId = lastSortId + selectedDirSortArr[ i];									moved = true;								} catch( e) {									// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる									prevPathArr.pop();								}							}							moveDoc( dir_hovered, prevPathArr);							break;														case Dir.HOVERED_STATUS_ON_UPPER:							// ----------------------------------------------------------------------------------							// ドラッグ先の１個上のフォルダにADDし、ソート順をドラッグ先のフォルダの一個前にする							// ----------------------------------------------------------------------------------							if( dir_hovered.parent as Dir == null) break;							// ドラッグ先親フォルダ内のchildrenについて、現状のXY位置からソートIDを振り直しておく							Dir( dir_hovered.parent).setChildSortIdByPosi( 0);							for( i = 0; i < m_selectedDirArr.length; i++) {								prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());								try {									dir_hovered.parent.addChild( m_selectedDirArr[ i]);									Dir( m_selectedDirArr[i]).sortId =										Dir( dir_hovered).sortId - 1											+ ( selectedDirSortArr[ i] + 1) / ( selectedDirSortArr[ m_selectedDirArr.length-1] + 2);									moved = true;								} catch( e) {									// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる									prevPathArr.pop();								}							}							moveDoc( Dir( dir_hovered.parent), prevPathArr);							break;						}											} else {						// ドラッグ先がファイルの場合						if( dir_hovered.parent as Dir != null) {							switch( dir_hovered.getHoveredStatus()) {								case Dir.HOVERED_STATUS_ON: // 何もしない								break;																case Dir.HOVERED_STATUS_ON_UNDER:								// ----------------------------------------------------------------------------------								// ドラッグ先の１個上のフォルダにADDし、ソート順をドラッグ先のファイルの一個後にする								// ----------------------------------------------------------------------------------																// ドラッグ先親フォルダ内のchildrenについて、現状のXY位置からソートIDを振り直しておく								Dir( dir_hovered.parent).setChildSortIdByPosi( 0);								for( i = 0; i < m_selectedDirArr.length; i++) {									prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());									try {										dir_hovered.parent.addChild( m_selectedDirArr[ i]);										Dir( m_selectedDirArr[i]).sortId =											Dir( dir_hovered).sortId												+ ( selectedDirSortArr[ i] + 1) / ( selectedDirSortArr[ m_selectedDirArr.length-1] + 2);										moved = true;									} catch( e) {										// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる										prevPathArr.pop();									}								}								moveDoc( Dir( dir_hovered.parent), prevPathArr);								break;																case Dir.HOVERED_STATUS_ON_UPPER:								// ----------------------------------------------------------------------------------								// ドラッグ先の１個上のフォルダにADDし、ソート順をドラッグ先のファイルの一個前にする								// ----------------------------------------------------------------------------------								Dir( dir_hovered.parent).setChildSortIdByPosi( selectedDirSortArr[ selectedDirSortArr.length-1] + 1);								for( i = 0; i < m_selectedDirArr.length; i++) {									prevPathArr.push( Dir( m_selectedDirArr[i]).getPath());									try {										dir_hovered.parent.addChild( m_selectedDirArr[ i]);										Dir( m_selectedDirArr[i]).sortId =											Dir( dir_hovered).sortId - 1												+ ( selectedDirSortArr[ i] + 1) / ( selectedDirSortArr[ m_selectedDirArr.length-1] + 2);										moved = true;									} catch( e) {										// 自分自身の子フォルダに追加しようとしていたら、追加失敗してる										prevPathArr.pop();									}								}								moveDoc( Dir( dir_hovered.parent), prevPathArr);								break;							}						}					}										dir_hovered.select( false);					replace();				}			}			if( !moved) {				Tweener.removeTweens( m_dragDir);				Tweener.addTween( m_dragDir, { x:m_dragDir.getStartX(), y:m_dragDir.getStartY(), time:0.25, onComplete:onCompleteDrag});			} else {				onCompleteDrag();			}						m_topDir.stopWatchHovered();		}				function moveDoc( dir_newParent:Dir, prevPathArr:Array) {			if( prevPathArr.length == 0) return;						var path:String = Main.CONF.getParam( "UPLOAD_URL");			if( path == LoadConf.NOTFOUND) {				alertDialog(  Main.LANG.getParam( "UPLOAD_URLが設定されていないためファイルを送信できませんでした"));				return;			}									var urlVar:URLVariables = new URLVariables();			var req:URLRequest = new URLRequest( path);			req.method = URLRequestMethod.POST;			urlVar.do_mode = "rename";			urlVar.class_id = Main.CONF.CLASS_ID;			//trace( "-----------", dir_newParent.getPath());			for( var i:uint = 0; i < prevPathArr.length; i++) {				urlVar["oldname_arr["+String( i)+"]"] = prevPathArr[i];				//trace( prevPathArr[i]);			}			urlVar.newdir = dir_newParent.getPath() == "" ? "" : dir_newParent.getPath() + "/";									req.data = urlVar;						var ldr:URLLoader = new URLLoader();						try {				ldr.load( req);			} catch( e:Error){				//return "資料一覧取得時エラー";			}//navigateToURL( req, "_blank");		}		// 0から始まるソート番号をつける		function getSelectedDirSortArrByPosi() : Array {			var sortIdArr:Array = new Array();			var objArr:Array = new Array();			var i:uint;			for( i = 0; i < m_selectedDirArr.length; i++) {				var rect:Rectangle = Dir( m_selectedDirArr[i]).getRect( this);				objArr.push( { x:rect.x, y:rect.y, i_selectedDirArr:i, sortId:0});				sortIdArr.push( 0);			}			objArr.sortOn( [ 'y', 'x'], [ Array.NUMERIC, Array.NUMERIC]);			for( i = 0; i < objArr.length; i++) {				objArr[i].sortId = i;			}			for each( var obj:Object in objArr) {				sortIdArr[ obj.i_selectedDirArr] = obj.sortId;			}			return sortIdArr;		}				function onCompleteDrag() {//trace( "onCompleteDrag");			if( contains( m_dragDir)) removeChild( m_dragDir);		}		function loadDocList() : String {						var path = Main.CONF.getParam( 'DOCLIST_URL');			if( ! path) return Main.LANG.getParam( "DOCLIST_URLが設定されていないため資料一覧を取得できませんでした");			//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "Thumbnails:" + path);			var req:URLRequest = new URLRequest( path);			var urlVar:URLVariables = new URLVariables();			var ldr:URLLoader = new URLLoader();						req.method = URLRequestMethod.POST;			urlVar.class_id = Main.CONF.CLASS_ID;			urlVar.do_mode = "list";			req.data = urlVar;					ldr.addEventListener( Event.COMPLETE, onLoadDocList);			ldr.addEventListener( IOErrorEvent.IO_ERROR, reDispatch);			ldr.addEventListener( SecurityErrorEvent.SECURITY_ERROR, reDispatch);						try {				ldr.load( req);Main.addDebugMsg( "FolderCon: loadDocList() call " + Main.CONF.getParam( 'DOCLIST_URL') + " do_mode=list");				} catch( e:Error){				return Main.LANG.getParam( "資料一覧取得時エラー");			}			return "";		}		function onLoadDocList( e:Event) {			var ldr:URLLoader = URLLoader ( e.target);//trace( ldr.data);//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", ldr.data);//Main.addDebugMsg( "FolderCon:onLoadDocList[" + ldr.data + "]");			try {				if( ldr.data != "") {					var flistXml:XML = new XML( XML( ldr.data));										for each( var ite in flistXml.file){//Main.addDebugMsg( "FolderCon:onLoadDocList " + ite.url);						if( ite.hasOwnProperty("docid")) {							// ファイル追加							if( !ite.docid || ite.docid == "") {								if( Main.CONF.isPro( Main.CONF.UID)) Main.addErrMsg( Main.LANG.getParam( "資料一覧取得時エラー") + ":docid is not set.\n" + ite.url);											continue;							}//Main.addDebugMsg( "FolderCon:onLoadDocList addDoc(" + ite.docid+ ")の開始");							addDoc( ite.url, ite.docid);						} else {							// ディレクトリ追加（空ディレクトリが存在している場合に備えて。）							m_topDir.addDir( ite);//Main.addDebugMsg( "FolderCon:onLoadDocList m_topDir.addDir(" + ite + ")");						}					}									} else {					dispatchEvent( new Event( XML_LOAD_ERROR));				}				dispatchEvent( new Event( XML_LOAD_COMPLETE));			} catch( e:Error) {				dispatchEvent( new Event( XML_LOAD_ERROR));			}//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "onLoadDocList():" + e.type);		}		function onLoadError( e:IOErrorEvent) {//Main.addErrMsg("FolderCon:onLoadError():" +  ( ( e.target) as Dir)?Dir( e.target).getPath() : e.target.name);//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "onLoadError():" + e.target.name);			var removed_doc:Doc = ( e.target) as Doc;			if( removed_doc != null) {				deleteDir( removed_doc, false);				m_docErrArr.push( removed_doc);			}			dispatchEvent( new Event( THU_LOAD_ERROR));		}		public function getErrDocName() : String{			var ret = "";			for each( var doc:Doc in m_docErrArr) {				if( ret != "") ret += " ";				ret += doc.getPath();			}			return ret;		}				public function addDoc( imgpath:String, docid:String = "") : Doc {			// 同じ画像が登録されていないかチェック			var exist = false;			var doc:Doc = null;			if( ! m_topDir.hasDoc( imgpath)) {				// 登録はされていない				// 既に読み込み失敗していたサムネイルに入っていないかチェック				for( var i = 0; i < m_docErrArr.length; i++) {					if( m_docErrArr[i].name == imgpath) {						exist = true;Main.addDebugMsg( "FolderCon:addDoc: IO Errorが過去に出たファイルなので追加キャンセル: " + imgpath);						break;					}				}			} else {				// 登録済み								// ここで、本来ならSOを更新しない（DocEvent.REMOVEDをdispatchしない）やり方で				// 古いものを削除すればいいのだけど、今はとりあえず登録キャンセル処理にしとく。Main.addDebugMsg( "FolderCon:addDoc: 登録済みなので追加キャンセル: " + imgpath);								exist = true;			}						if( !exist) {				// 新規追加				doc = m_topDir.addPathDoc( imgpath, docid); // フォルダとファイルを一度に追加								//doc.addEventListener( DocEvent.LOAD_COMPLETE, reDispatchDocEvent);				doc.addEventListener( DocEvent.SELECTED, onDocSelected);				doc.addEventListener( DocEvent.REMOVED, reDispatchDocEvent);				doc.addEventListener( DocEvent.ADDED, reDispatchDocEvent);								doc.addEventListener( IOErrorEvent.IO_ERROR, onLoadError);				//Main.addDebugMsg( "FolderCon:addDoc: 新規追加 imgpath:" + imgpath + " docid:" + docid);				doc.prepare( imgpath);								if( m_listtype == ListTypeBtn.TEXT_CLICKED) {					var dir_added:Dir = doc.parent as Dir;					if( dir_added != null && ! dir_added.isOpened()) dir_added.open( true);				} else {					doc.visible = true;				} 								setListType( m_listtype);								return doc; // 追加完了							} else {				return null; // 追加キャンセル			}					}				public function getDocById( id:String) : Doc {			return m_topDir.getDocById( id);		}				// WhiteboardContainerのso_slideListの変更時に呼ばれる。		// so_slideListが[WBユーザ/講師]によって変更されていたものならば		// [講師/WBユーザ]のサムネイル状態を相手に合わせる必要があるため		// ここにあってobjArrに無いものは削除する		public function removeDoc_IfMissMatch( objArr:Array, flistXml:XML = null) {			removeDoc_IfMissMatch_private( m_topDir, objArr);									// Docが含まれていないフォルダがあった場合、そのフォルダが実際に存在するかチェックするため			if( flistXml == null) {				// もう一度資料一覧を取得する								var path = Main.CONF.getParam( 'DOCLIST_URL');				if( ! path) return;								var req:URLRequest = new URLRequest( path);				var urlVar:URLVariables = new URLVariables();				var ldr:URLLoader = new URLLoader();								req.method = URLRequestMethod.POST;				urlVar.class_id = Main.CONF.CLASS_ID;				urlVar.do_mode = "list";				req.data = urlVar;							ldr.addEventListener( Event.COMPLETE, onCheckDirExistence);				ldr.addEventListener( IOErrorEvent.IO_ERROR, reDispatch);				ldr.addEventListener( SecurityErrorEvent.SECURITY_ERROR, reDispatch);				ldr.load( req);Main.addDebugMsg( "FolderCon: removeDoc_IfMissMatch() call " + Main.CONF.getParam( 'DOCLIST_URL') + " do_mode=list");								} else {				removeDir_IfMissMatch( flistXml);			}		}		function removeDir_IfMissMatch( flistXml:XML) {Main.addDebugMsg( "FolderCon: removeDir_IfMissMatch:TODO");return;			var existDir_arr:Array = new Array();			for each( var ite in flistXml.file){				if( ite.hasOwnProperty("docid")) {					// ファイルは無視				} else {					// 存在しているディレクトリ					existDir_arr.push( ite);				}			}						// m_topDir配下にaddChildされているが、existDir_arrには入っていないDirをremoveする// TODO		}		function onCheckDirExistence( e:Event) {Main.addDebugMsg( "FolderCon: onCheckDirExistence:TODO");	trace( "FolderContainer:onCheckDirExistence:TODO");return;			if( ldr.data != "") {				var flistXml:XML = new XML( XML( ldr.data));				removeDir_IfMissMatch( flistXml);							} else {				// 全部空なので、全部削除する			}		}		function removeDoc_IfMissMatch_private( dir_parent:Dir, objArr:Array) {			for( var i = 0; i < dir_parent.numChildren; i++) {				var child = dir_parent.getChildAt( i);				if( child as Doc != null) {										var exist:Boolean = false;										for each( var obj:Object in objArr) {						if( obj.bgtype == WhiteboardContainer.BGTYPE_IMG && obj.param == child.getId()) {							exist = true;							break;						}					}					if( ! exist) {//Main.addDebugMsg("FCon:removeDoc_IfMissMatch_private:" + Doc(child).getPath());						deleteDir( child, false, false);						i--;					}									} else if( child as Dir != null) {					removeDoc_IfMissMatch_private( child, objArr);				}			}		}				// WhiteboardContainerのSharedObject：so_wbNowが変更されたときにImgdocContainerから呼ばれる。		// サムネイルの選択状態を変更する		public function setSelected( docid:String) {			m_topDir.offAllChildren( null);			var doc:Doc = m_topDir.getDocById( docid);			if( doc != null) doc.select( true);		}				// ImgdocContainer:onMinusBtnClick()から呼ばれる。		// 全てのサムネイルのファイル名を返す		public function getAllThumb():Array {			var arr:Array = new Array()			/*for( var i = 0; i < m_docArr.length; i++) {				arr.push( m_docArr[ i].name);			}*/			return arr;		}		public function getTopDir() : Dir { return m_topDir;}								// この関数が呼ばれるのは、Thumbnails.XML_LOAD_COMPLETEがdispatchされた後に		// SharedObjectが初めて読み込まれた時		public function init_sort( so_sortId:SharedObject) {		}				// サムネイルの手動ソート操作が行われた後にImgdocContainer経由でWhiteboardContainerから呼ばれる		public function getSortIdHash() : Object {			var hash:Object = new Object();			return hash;		}				public function setListType( type:String) {			if( m_listtype == ListTypeBtn.TEXT_CLICKED && type == ListTypeBtn.THUMB_CLICKED) {				// テキスト表示からサムネイル表示に切り替わるとき				// 現在選択中のフォルダのうち、最上位のフォルダをm_spreadDirとする。				// (選択中のものがファイルだった場合はその一個上のフォルダをm_spreadDirとする。)				m_spreadDir = m_topDir.getSelectedTopDir();//trace( m_spreadDir.name);			}			m_listtype = type;			if( m_spreadDir == null || m_listtype == ListTypeBtn.TEXT_CLICKED) m_spreadDir = m_topDir;			replace();			m_topDir.offAllChildren( null);					}				// ImgdocContainer:fileUploadResultHandler()から呼ばれる		public function fresh() {			replace();		}				// ImgdocContainer:サムネイル一覧の「一個上のフォルダ」ボタンクリック時に呼ばれる		public function changeSpreadDir() {			if( m_spreadDir == null) return;			if( m_spreadDir == m_topDir) return;			m_spreadDir = Dir( m_spreadDir.parent);			replace();		}				function replace() {			// サムネイルを並べ直す			m_topDir.setListtype( m_listtype);			if( m_listtype == ListTypeBtn.TEXT_CLICKED) {				m_topDir.replaceChildren( 0);			} else {				m_topDir.spread( m_spreadDir, W);			}						dispatchEvent( new Event( REPLACED));			//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "replace:" + " "+ Math.random());		}				public function getSpreadDir() : Dir { return m_spreadDir;}		public function getListtype() : String { return m_listtype;}		public function getViewWidth(){ return W;}		public function setViewWidth( w:Number) {			//if( W == w) return;//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "FCon:setViewWidth():"+ w + "->" + W + "  " + Math.random());						W = w;			if( m_listtype == ListTypeBtn.TEXT_CLICKED) {				m_topDir.setViewWidth( w);			}			else {				m_topDir.unspreadAllChildren();				m_spreadDir.spreadChildren( W);				dispatchEvent( new Event( REPLACED));			}					}				function reDispatch( e:*) { dispatchEvent( e);}		function reDispatchDirEvent( e:DirEvent) {			dispatchEvent( new DirEvent( e.type, e.dir)); // ImgdocContainerに知らせる		}		function reDispatchDocEvent( e:DocEvent) {			dispatchEvent( new DocEvent( e.type, e.doc)); // ImgdocContainerに知らせる		}		function onDocSelected( e:DocEvent) {//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_alert", "FolderCon:onDocSelected [" + m_shiftKey + "][" + m_ctrlKey + "]");					if( !m_shiftKey && !m_ctrlKey) dispatchEvent( new DocEvent( DocEvent.SELECTED, e.doc)); // ImgdocContainerに知らせる		}		function wait( count:uint ):void{			var start:uint = getTimer();			while( getTimer() - start < count){			}		}		function alertDialog( str) {			Main.addErrMsg( "FolderContainer:" + str);		}	}}