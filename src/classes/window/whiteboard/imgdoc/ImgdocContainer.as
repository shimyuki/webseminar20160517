package window.whiteboard.imgdoc {	import flash.display.*;	import flash.geom.*;	import common.*;	import window.*;	import window.whiteboard.*;	//import window.whiteboard.toolchip.*;	import flash.text.*;	import flash.events.*;	import flash.net.*;	import flash.utils.*;	import com.hurlant.util.*;	import common.AlertManager; 		// 資料コンテナ	public class ImgdocContainer extends ResizableContainer {		static public const OPENED:String = "ToolchipContainer.OPENED";		static public const CLOSED:String = "ToolchipContainer.CLOSED";		static public const CHANGE_FOLDER_NAME:String = "CHANGE_FOLDER_NAME";		//static public const RELOAD_BTN_CLICKED:String = "RELOAD_BTN_CLICKED";		static public const MSG_CONFIRM_ALL_DELETE:String = Main.LANG.getParam( "アップロードされた全ての資料を削除します");		private const INIT_Y_TYPE_TEXT = 0;		private const INIT_Y_TYPE_THUMB = 36;		private const FOOTER_H = 13;		private var m_closeText;		private var m_container:FolderContainerParent;		private var m_containerMask:Sprite;		private var m_scroll:SimpleScrollBar;		private var m_btnCon:Sprite;		private var m_btnParent;		private var m_btnPlus;		private var m_btnMinus;		private var m_btnMinusAll;		private var m_btnReload;		//private var m_btnListType;		//private var m_btnSort;		private var m_fileStatus:TextField;		private var m_frList:FileReferenceList;		private var m_folderCon:FolderContainer;		private var m_fileAddedDir:Dir;		private var m_thumbs;		private const PAD_THUMBS = 5;				private var m_preW:Number = 0;		private var m_preH:Number = 0;				private var m_uploadingCnt:Number;				private var m_objArr;						public function ImgdocContainer() {			super( OpenCloseBtn.W, 200, OpenCloseBtn.W, 80, /*0xf2f2f2*/Main.BASE_COLOR_02);						m_closeText = addChild( Main.LANG.getImgdocCloseText());			m_closeText.y = 5;						// 一覧表示コンテナ			m_container = FolderContainerParent( addChild( new FolderContainerParent()));			m_container.y = INIT_Y_TYPE_THUMB;			m_container.addEventListener( FolderContainerParent.CHANGE_Y, onChangeFolderContainerY);						// 一覧表示コンテナのマスク			m_containerMask = Sprite( addChild( new Sprite()));			m_containerMask.graphics.beginFill(0);			m_containerMask.graphics.drawRect( 0, 0, 1, 1);			m_containerMask.y = m_container.y;			m_container.mask = m_containerMask;						// 一覧表示コンテナの上（外）にボタンを追加			m_btnCon = Sprite( addChild( new Sprite()));			m_btnParent = m_btnCon.addChild( new IconPartsBtn( new IconParent(), 22, 22));			m_btnPlus = m_btnCon.addChild( new IconPartsBtn( new iconPlus(), 22, 22));			m_btnMinus = m_btnCon.addChild( new IconPartsBtn( new iconMinus(), 22, 22));			m_btnMinusAll = m_btnCon.addChild( new IconPartsBtn( new iconMinusAll(), 22, 22));			m_btnReload = m_btnCon.addChild( new IconPartsBtn( new IconReload(), 22, 22));//m_btnReload.visible = false;			m_btnParent.x = 10;			m_btnPlus.x = m_btnParent.x + m_btnParent.width + 3;			m_btnMinus.x = m_btnPlus.x + m_btnPlus.width + 3;			//m_btnMinusAll.x = m_btnMinus.x + m_btnMinus.width + 3;			//m_btnReload.x = m_btnMinusAll.x + m_btnMinusAll.width + 3;m_btnMinusAll.visible = false;			m_btnReload.x = m_btnMinus.x + m_btnMinus.width + 3;			m_btnParent.y = m_btnPlus.y = m_btnMinus.y = m_btnMinusAll.y = m_btnReload.y = 6.5;									// ファイルステータステキスト			m_fileStatus = addChild( new TextField()) as TextField;			m_fileStatus.x = m_btnReload.x + m_btnReload.width + 5;//m_fileStatus.x = m_btnMinusAll.x + m_btnMinusAll.width + 5;			m_fileStatus.y = 5;			m_fileStatus.defaultTextFormat = new TextFormat( "", 9, 0xcc0000);			m_fileStatus.autoSize = TextFieldAutoSize.LEFT;			m_frList = new FileReferenceList();			m_frList.addEventListener( Event.SELECT, onSelect);						// サムネイルコンテナ			m_folderCon = FolderContainer( m_container.addChild( new FolderContainer()));			m_folderCon.x = PAD_THUMBS;			//m_thumbs.y = 36;						m_folderCon.addEventListener( IOErrorEvent.IO_ERROR, function( e:*){ m_fileStatus.text = "ioError"});			m_folderCon.addEventListener( SecurityErrorEvent.SECURITY_ERROR, function( e:*){ m_fileStatus.text = "securityError"});			m_folderCon.addEventListener( FolderContainer.XML_LOAD_COMPLETE,										function( e:Event){											dispatchEvent( e);											m_fileStatus.text = "";										 	setListType(ListTypeBtn.THUMB_CLICKED);										});			m_folderCon.addEventListener( FolderContainer.XML_LOAD_ERROR, function( e:Event){ m_fileStatus.text = e.type;});			m_folderCon.addEventListener( FolderContainer.THU_LOAD_ERROR, function( e:Event){ m_fileStatus.text = FolderContainer.THU_LOAD_ERROR + ":" + m_folderCon.getErrDocName();});			//m_folderCon.addEventListener( DocEvent.LOAD_COMPLETE, function( e:DocEvent){});			m_folderCon.addEventListener( DocEvent.ADDED, function( e:DocEvent){ dispatchEvent( new DocEvent( e.type, e.doc));});						m_folderCon.addEventListener( DirEvent.PLUS_CLICKED, onDirPlusClicked);			m_folderCon.addEventListener( FolderContainer.REPLACED, onReplaced);			m_folderCon.addEventListener( DirEvent.MINUS_CLICKED, onDirMinusClicked);						m_fileStatus.text = m_folderCon.init();			// 一覧表示コンテナのスクロールバー			m_scroll = addChild( new SimpleScrollBar()) as SimpleScrollBar;			m_scroll.y = INIT_Y_TYPE_THUMB;			m_scroll.setSize( m_scroll.width, 200);						m_scroll.setScrollTarget( m_container);			m_scroll.scrollMask = m_containerMask;						addEventListener( Event.ADDED_TO_STAGE, function( e:*) {							 if( m_fileStatus) m_fileStatus.text = "";							/* stage.addEventListener( MouseEvent.CLICK, function( e:*) {													if( m_fileStatus) m_fileStatus.text = "";													});*/							 });					}				public function setFileStatusText( str:String) {			m_fileStatus.text = str;		}				// m_containerのY位置が変わったときに呼ばれる		function onChangeFolderContainerY( e:Event) {			loadImageWithinMask();		}				function loadImageWithinMask() {			// 見える部分にあるDocだけサムネイル表示（読み込み）			if( stage == null) return;			m_folderCon.loadImageWithin( m_containerMask.getRect( stage));		}				// WhiteboardContainerから、BgSelectorのDocStepperの設定用に呼ばれる		// 引数のDocと同じフォルダに「前の資料」に概要するDocが存在していればtrueを返す		public function existPrevDoc( doc:Doc) : Boolean {			//return m_folderCon.existPrevDoc();			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:existPrevDoc() unexpected error");				return false;			}			var tmp:Array = getSortedChildDoc( parentDir);			for( var i = 0; i < tmp.length; i++) {				var child = Doc( tmp[i]);				if( child == doc) {					if( i != 0) return true;					else return false;				}			}			// ここにはこないはず			errDialog( "ImgdocContainer:existPrevDoc() unexpected error");			return false;		}		// WhiteboardContainerから、BgSelectorのDocStepperの設定用に呼ばれる		// 引数のDocと同じフォルダに「次の資料」に概要するDocが存在していればtrueを返す		public function existNextDoc( doc:Doc) : Boolean {			//return m_folderCon.existPrevDoc();			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:existNextDoc() unexpected error");				return false;			}			var tmp:Array = getSortedChildDoc( parentDir);			for( var i = 0; i < tmp.length; i++) {				var child = Doc( tmp[i]);				if( child == doc) {					if( i < tmp.length - 1) return true;					else return false;				}			}			// ここにはこないはず			errDialog( "ImgdocContainer:existNextDoc() unexpected error");			return false;		}				function getSortedChildDoc( parentDir:Dir) : Array {			var tmp:Array = new Array();			var child:Doc;			for( var i = 0; i < parentDir.numChildren; i++) {				child = parentDir.getChildAt( i) as Doc;				if( child != null) {					tmp.push( child);				}			}			tmp.sortOn( [ "sortId", "name"], [ Array.NUMERIC]);			return tmp;		}				public function select1stDoc( currentDocId:String) {			var doc:Doc = getDocById( currentDocId);			if( doc == null) {				errDialog( "ImgdocContainer:select1stDoc() unexpected currentDocId:" + currentDocId);				return;			}			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:select1stDoc() unexpected error");				return;			}			var tmp:Array = getSortedChildDoc( parentDir);			if( tmp.length == 0) {				errDialog( "ImgdocContainer:select1stDoc() unexpected error");				return;			}			var targetDoc:Doc = Doc( tmp[0]);			targetDoc.selectByDocStepper();					}		public function selectBackDoc( currentDocId:String) {			var doc:Doc = getDocById( currentDocId);			if( doc == null) {				errDialog( "ImgdocContainer:selectBackDoc() unexpected currentDocId:" + currentDocId);				return;			}			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:selectBackDoc() unexpected error");				return;			}			var tmp:Array = getSortedChildDoc( parentDir);			var target_i = -1;			for( var i = 0; i < tmp.length; i++) {				var child = Doc( tmp[i]);				if( child == doc) {					target_i = i - 1;					break;				}			}			if( target_i != -1) {				var targetDoc:Doc = Doc( tmp[ target_i]);				targetDoc.selectByDocStepper();			} else {				// ここにはこないはず				errDialog( "ImgdocContainer:selectBackDoc() unexpected error");				return;			}		}		public function selectNextDoc( currentDocId:String) {			var doc:Doc = getDocById( currentDocId);			if( doc == null) {				errDialog( "ImgdocContainer:selectNextDoc() unexpected currentDocId:" + currentDocId);				return;			}			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:selectNextDoc() unexpected error");				return;			}			var tmp:Array = getSortedChildDoc( parentDir);			var target_i = tmp.length;			for( var i = 0; i < tmp.length; i++) {				var child = Doc( tmp[i]);				if( child == doc) {					target_i = i + 1;					break;				}			}			if( target_i != tmp.length) {				var targetDoc:Doc = Doc( tmp[ target_i]);				targetDoc.selectByDocStepper();			} else {				// ここにはこないはず				errDialog( "ImgdocContainer:selectNextDoc() unexpected error");				return;			}		}		public function selectLastDoc( currentDocId:String) {			var doc:Doc = getDocById( currentDocId);			if( doc == null) {				errDialog( "ImgdocContainer:selectLastDoc() unexpected currentDocId:" + currentDocId);				return;			}			var parentDir:Dir = doc.parent as Dir;			if( parentDir == null) {				errDialog( "ImgdocContainer:selectLastDoc() unexpected error");				return;			}			var tmp:Array = getSortedChildDoc( parentDir);			if( tmp.length == 0) {				errDialog( "ImgdocContainer:selectLastDoc() unexpected error");				return;			}			var targetDoc:Doc = Doc( tmp[tmp.length - 1]);			targetDoc.selectByDocStepper();					}				// WhiteboardContainerから呼ばれる		public function getDocById( id:String) : Doc {			return m_folderCon.getDocById( id);		}				function onReplaced( e:Event) {			var spread_parent_exist:Boolean = false;			if( m_folderCon.getListtype() == ListTypeBtn.THUMB_CLICKED) {				var spreadDir:Dir = m_folderCon.getSpreadDir();				if( spreadDir != null && spreadDir.parent as Dir != null) {					spread_parent_exist = true;				}			}			if( spread_parent_exist) {				m_btnParent.setEnabled( true);				m_btnParent.addEventListener( MouseEvent.CLICK, onParentBtnClick);			} else {				m_btnParent.setEnabled( false);				m_btnParent.removeEventListener( MouseEvent.CLICK, onParentBtnClick);			}			m_scroll.update();			dispatchEvent( new Event( CHANGE_FOLDER_NAME));			dispatchEvent( new Event( FolderContainer.REPLACED));//Main.addDebugMsg( "---------------- imgdocCon onReplaced()");						loadImageWithinMask();		}		// ImgdocWindowからよばれる		public function getFolderName():String {			if( m_folderCon.getListtype() == ListTypeBtn.THUMB_CLICKED) {				var spreadDir:Dir = m_folderCon.getSpreadDir();				if( spreadDir == null) return "";				else return spreadDir.getName();			} else {				return "";			}		}		function onParentBtnClick( e:Event) {			m_folderCon.changeSpreadDir();			if( m_uploadingCnt == 0) m_fileStatus.text = "";		}				public function init_sort( so_sortId:SharedObject) {			//m_thumbs.init_sort( so_sortId);			m_folderCon.init_sort( so_sortId);		}				// サムネイルの手動ソート操作が行われた後にWhiteboardContainerから呼ばれる		public function getSortIdHash() : Object {//trace("ImgdocContainer:getSortIdHash()未実装");Main.addErrMsg( "ImgdocContainer:getSortIdHash()未実装");			return null;			//return m_thumbs.getSortIdHash();		}				function onMinusBtnClick( e:MouseEvent) {			var deletingDocIdArr:Array = new Array();			var selectedDirArr:Array = m_folderCon.getTopDir().getSelectedChildren(); // じかに選択中のDir配列を取得			for each( var dir in selectedDirArr) {				if( dir as Doc != null) {					deletingDocIdArr.push( Doc( dir).getId());				} else {					var docArr:Array = Dir( dir).getAllDocs();					for each( var doc:Doc in docArr) {						deletingDocIdArr.push( doc.getId());					}				}			}			dispatchEvent( new PreMultiDocRemoveEvent( PreMultiDocRemoveEvent.REMOVED, deletingDocIdArr));						  			m_folderCon.deleteSelectedDir();						if( m_uploadingCnt == 0) m_fileStatus.text = "";		}				function onAllMinusBtnClick( e:MouseEvent) {			var deletingDocIdArr:Array = new Array();			var docArr:Array = m_folderCon.getTopDir().getAllDocs();			for each( var doc:Doc in docArr) {				deletingDocIdArr.push( doc.getId());			}			dispatchEvent( new PreMultiDocRemoveEvent( PreMultiDocRemoveEvent.REMOVED, deletingDocIdArr));						m_folderCon.deleteAll();						if( m_uploadingCnt == 0) m_fileStatus.text = "";		}		function onDirMinusClicked( e:DirEvent) {			var deletingDocIdArr:Array = new Array();			var docArr:Array = e.dir.getAllDocs();			for each( var doc:Doc in docArr) {				deletingDocIdArr.push( doc.getId());			}			dispatchEvent( new PreMultiDocRemoveEvent( PreMultiDocRemoveEvent.REMOVED, deletingDocIdArr));						  			m_folderCon.deleteSelectedDir();						if( m_uploadingCnt == 0) m_fileStatus.text = "";		}				function onReloadBtnClick( e:MouseEvent) {			//var ret = ExternalInterface.call( "flashFunc_comfirm", "従来通りinitするならOK、updateFolderConするならキャンセル");//if( ret) {			if( m_folderCon.getListtype() == ListTypeBtn.THUMB_CLICKED) {				while( m_folderCon.getSpreadDir() != m_folderCon.getTopDir()) {					m_folderCon.changeSpreadDir();				}			} else {				//Main.addErrMsg( "ImgdocContainer:onReloadBtnClick() TEXT表示の場合のリロードボタン押下は未実装です");			}			m_fileStatus.text = m_folderCon.init();//} else {//	dispatchEvent( new Event( RELOAD_BTN_CLICKED));//}		}				public function reloadThumbXml() {			m_folderCon.init();		}				// WhiteboardContainerのSharedObject：so_wbNowが変更されたときに呼ばれる。		// サムネイルの選択状態を変更する		public function setSelected( docid:String) {			m_folderCon.setSelected( docid);		}		function onDirPlusClicked( e:DirEvent) {			m_fileAddedDir = e.dir;			m_frList.browse();		}				function onPlusBtnClick( e:MouseEvent):void {			if( m_folderCon.getListtype() == ListTypeBtn.TEXT_CLICKED) {				m_fileAddedDir = m_folderCon.getTopDir();			} else {				m_fileAddedDir = m_folderCon.getSpreadDir();				if( m_fileAddedDir == null) m_fileAddedDir = m_folderCon.getTopDir();			}			m_frList.browse( /*[ new FileFilter( "Images", "*.jpg;*.gif;*.png"), new FileFilter("Documents", "*.pdf")]*/);		}				function onSelect( e:Event):void {						var frList:FileReferenceList = FileReferenceList( e.target);			frList.fileList.sortOn( "name");						/*if( frList.fileList.length > Number( Main.CONF.getParam("max_file_uploads"))) {				m_fileStatus.text = "ERROR: cannot upload more than " + Main.CONF.getParam("max_file_uploads")+" files.";			}*/			for ( var i:uint = 0; i < frList.fileList.length; i++) {				var fr:FileReference = FileReference( frList.fileList[i]);				var errMsg:String;				if( fr.size > Number( Main.CONF.getParam("upload_max_filesize")) || fr.size > Number( Main.CONF.getParam("post_max_size"))) {					errMsg = "ERROR: cannot upload " + fr.name + " ["+fr.size+" bytes].\n";					errMsg += " -> upload_max_filesize is " + Main.CONF.getParam("upload_max_filesize") +" bytes (php.ini settting).\n";					errMsg += " -> post_max_size is " + Main.CONF.getParam("post_max_size") +" bytes (php.ini settting).\n";					//errDialog( errMsg);					AlertManager.createAlert( this, errMsg);					continue;				}				// Office文書には未対応var office:Boolean;if( fr.type != null) {	if( fr.type.match( /PDF/i)) office = false;	else if( fr.type.match( /png/i) || fr.type.match( /gif/i) || fr.type.match( /jpg/i) || fr.type.match( /jpeg/i) ||  fr.type.match( /bmp/i)) office = false;	else office = true;} else if( fr.name) {	if( fr.name.match( /.PDF$/i)) office = false;	else if( fr.name.match( /png/i) || fr.name.match( /gif/i) || fr.name.match( /jpg/i) || fr.name.match( /jpeg/i) || fr.name.match( /bmp/i)) office = false;	else office = true;}if( office) {	errMsg = "ERROR: cannot upload " + fr.name + "\n";	errMsg += " -> only image or pdf file is supported.\n";	//errDialog( errMsg);	AlertManager.createAlert( this, errMsg);	continue;}				fr.addEventListener( Event.OPEN, onOpen);				fr.addEventListener( ProgressEvent.PROGRESS, onProgress);				fr.addEventListener( DataEvent.UPLOAD_COMPLETE_DATA, fileUploadResultHandler);				fr.addEventListener( IOErrorEvent.IO_ERROR, ioErrorHandler);				fr.addEventListener( SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);								var urlVar:URLVariables = new URLVariables();				var req:URLRequest = new URLRequest();				req.method = URLRequestMethod.POST;								//var header:URLRequestHeader	= new URLRequestHeader("Authorization", "Basic " + Base64.encode( "school:123456"));				//req.requestHeaders.push( header );						if( fr.type != null) {					if( fr.type.match( /PDF/i)) urlVar.do_mode = "up-pdf";					else if( fr.type.match( /png/i) || fr.type.match( /gif/i) || fr.type.match( /jpg/i) || fr.type.match( /jpeg/i) ||  fr.type.match( /bmp/i)) urlVar.do_mode = "up-doc";					else urlVar.do_mode = "up-office";				} else if( fr.name) {					if( fr.name.match( /.PDF$/i)) urlVar.do_mode = "up-pdf";					else if( fr.name.match( /png/i) || fr.name.match( /gif/i) || fr.name.match( /jpg/i) || fr.name.match( /jpeg/i) || fr.name.match( /bmp/i)) urlVar.do_mode = "up-doc";					else urlVar.do_mode = "up-office";				} else {					errDialog( "ERROR: "+Main.LANG.getParam( "ファイル情報を取得できません"));										return;				}				urlVar.class_id = Main.CONF.CLASS_ID;								var targetDir = m_fileAddedDir.getPath();				urlVar.targetDir = targetDir == "" ? "" : targetDir + "/";				//Main.addErrMsg( Main.CONF.getParam( 'UPLOAD_URL') + " domode: " + urlVar.do_mode + " / target: " + urlVar.targetDir + fr.name);				/*				// 番号取得				var str_num:String = String( i);				if( str_num.length == 1) str_num = "000" + str_num;				else if( str_num.length == 2) str_num = "00" + str_num;				else if( str_num.length == 3) str_num = "0" + str_num;								urlVar.newfilename = newFilename + "_" + str_num;								*/				req.data = urlVar;				var path = Main.CONF.getParam( 'UPLOAD_URL');				if( path) {					req.url = path;					fr.upload( req);								uploadStarted();				} else {					m_fileStatus.text = Main.LANG.getParam( "UPLOAD_URLが設定されていないためアップロードできませんでした");				}				// スリープ				wait( 250);			}					}		public function initStatus() {			m_uploadingCnt = 0;		}		function uploadStarted() {			m_uploadingCnt++;			m_btnReload.setEnabled( false);			m_btnPlus.setEnabled( false);			m_btnMinus.setEnabled( false);			m_btnMinusAll.setEnabled( false);//Main.addDebugMsg( "uploadStarted" + m_uploadingCnt);		}		function uploadFinished() {			m_uploadingCnt--;			if( m_uploadingCnt <= 0) {				m_btnReload.setEnabled( true);				m_btnPlus.setEnabled( true);				m_btnMinus.setEnabled( true);				m_btnMinusAll.setEnabled( true);				m_uploadingCnt = 0;			}//Main.addDebugMsg( "uploadFinished" + m_uploadingCnt);		}				function wait( count:uint ):void{			var start:uint = getTimer();			while( getTimer() - start < count){			}		}		function onOpen( e:Event):void {			m_fileStatus.text = Main.LANG.getParam( "ファイル送信開始");		}		function onProgress(e:ProgressEvent):void{			// アップロードのプログレスバー表示とかするときに			m_fileStatus.text = Main.LANG.getParam( "ファイル送信中…") + String( Math.floor( e.bytesLoaded / e.bytesTotal * 100)) + "%";			if( e.bytesLoaded == e.bytesTotal) m_fileStatus.text = Main.LANG.getParam( "ファイル送信完了") + ", " + Main.LANG.getParam( "処理中…");Main.addErrMsg( e.target.name + ": " + m_fileStatus.text);		}		function fileUploadResultHandler( e:DataEvent):void		{			// fileUploadedHandler のあとに、サーバースクリプトを経て帰ってくるデータ			// サーバー側は必ずアップロードしたファイルのURLを返す									if( String( e.data) == Main.CONF.getParam( 'UP_OFFICE_IGNORE')) {				//m_fileStatus.text = "Office文書がアップロードされました";				m_fileStatus.text = "";			} else {								var url_arr:Array = e.data.split( ";");				var multiUploadManagerArr:MultiUploadManager = new MultiUploadManager();				multiUploadManagerArr.addEventListener( "complete", onMultiDocComplete);				var errMsg = "";				var files = "";				for( var i = 0; i < url_arr.length; i++) {					if( isDocPath( url_arr[i])) {						var doc:Doc = m_folderCon.addDoc( url_arr[i]);						if( doc != null) multiUploadManagerArr.watchDoc( doc);						files += " + " + url_arr[i];						if( i != url_arr.length - 1) files += "<br />";					} else if( url_arr[i] != "") {						errMsg += "[" + url_arr[i] + "]<br />";					}				}				if( errMsg != "") Main.addErrMsg(  Main.LANG.getParam( "一部のファイルアップロードに失敗しました") + "<br />" + errMsg);							}Main.addErrMsg( e.target.name + ": LOAD COMPLETE!<br />" + files);						uploadFinished();			m_scroll.update();		}		function onMultiDocComplete( e:Event) {			var multiUploadManagerArr:MultiUploadManager = MultiUploadManager( e.target);			dispatchEvent( new DocEventMulti( DocEventMulti.ADDED, multiUploadManagerArr.docArr));			m_fileStatus.text = Main.LANG.getParam( "追加完了");		}				function isDocPath( str:String) :Boolean {			if( str.indexOf( "http") == 0 && str.indexOf( "/") > 0 &&			   str.substr( str.length - 2, 1) != "/") return true;			return false;		}				// WhiteboardContainerのso_slideListの変更時に呼ばれる。		// so_slideListが[WBユーザ/講師]によって変更されていたものならば		// [講師/WBユーザ]のサムネイル状態を相手に合わせる必要があるため		public function updateFolderCon( objArr) {//Main.addDebugMsg( "ImgdocCon: updateFolderCon");			m_objArr = objArr;			// objArrにあってm_folderConに無いものは追加する						var path = Main.CONF.getParam( 'DOCLIST_URL');			if( path == LoadConf.NOTFOUND) {				alertDialog( Main.LANG.getParam( "DOCLIST_URLが設定されていないためファイルを取得できませんでした"));				return;			}						var new_docid_arr:Array = new Array();			for each( var obj in objArr) {				//（既に追加済みならなにも起こらないはず）				if( obj.bgtype == WhiteboardContainer.BGTYPE_IMG) {					if( m_folderCon.getDocById( obj.param) == null) {						new_docid_arr.push( obj.param);					}				}			}			if( new_docid_arr.length > 0) {				var req:URLRequest = new URLRequest( path);				var urlVar:URLVariables = new URLVariables();				var ldr:URLLoader = new URLLoader();								req.method = URLRequestMethod.POST;				urlVar.class_id = Main.CONF.CLASS_ID;				urlVar.do_mode = "list";				req.data = urlVar;							ldr.addEventListener( Event.COMPLETE, onLoadDocList_4_updateFolderCon);				ldr.load( req);		Main.addErrMsg( "ImgdocCon: updateFolderCon() call " + Main.CONF.getParam( 'DOCLIST_URL') + " do_mode=list");					/*if( new_docid_arr.length == 1) {						Main.addDebugMsg( "ImgdocCon: updateFolderConで一件のみ追加:" + new_docid_arr[0]);						// 一件だけ追加する					// docidからimgpathを取得し（PHP）					// addDocを実行する。																var req:URLRequest = new URLRequest( path);					var urlVar:URLVariables = new URLVariables();					var ldr:URLLoader_loadDocid = new URLLoader_loadDocid( new_docid_arr[0]);										req.method = URLRequestMethod.POST;					urlVar.class_id = Main.CONF.CLASS_ID;					urlVar.do_mode = "url";					urlVar.docid = new_docid_arr[0];					req.data = urlVar;									ldr.addEventListener( Event.COMPLETE, onLoadUrl);					function onLoadUrl( e:Event) {						var imgpath = URLLoader_loadDocid( e.target).data;						if( isDocPath( imgpath)) {							m_folderCon.addDoc( imgpath, URLLoader_loadDocid( e.target).docid);						} else {							//Main.addDebugMsg( Main.LANG.getReplacedSentence( "docid[%s]に対応する資料が見つかりませんでした", URLLoader_loadDocid( e.target).docid)+"\n" + imgpath);							Main.addDebugMsg( "ImgdocContainer docid["+URLLoader_loadDocid( e.target).docid+"]からURLを問い合わせた結果、" + imgpath + " というURLを取得しました。これは正常なURLではないので、読み込むことができません");						}					}										try {						ldr.load( req);					} catch( e:Error){					}										} else {Main.addDebugMsg( "ImgdocCon: updateFolderConで複数追加:" + new_docid_arr);										}*/						} else {							// m_folderConにあってobjArrに無いものは削除する				m_folderCon.removeDoc_IfMissMatch( objArr);			}		}		function onLoadDocList_4_updateFolderCon( e:Event) {			var ldr:URLLoader = URLLoader ( e.target);			if( ldr.data != "") {				var flistXml:XML = new XML( XML( ldr.data));								for each( var ite in flistXml.file){					if( ite.hasOwnProperty("docid")) {						if( isDocPath( ite.url)) {							m_folderCon.addDoc( ite.url, ite.docid);						} else {							Main.addDebugMsg( "ImgdocContainer getDoclist(do_mode=list)をリクエストした結果、" + ite.url + " というURLを取得しました。これは正常なURLではないので、読み込むことができません");						}											}				}				// m_folderConにあってobjArrに無いものは削除する				m_folderCon.removeDoc_IfMissMatch( m_objArr, flistXml);			}		}				function ioErrorHandler(event:IOErrorEvent):void{			// サーバーサイドスクリプトに Flash が到達できない場合			m_fileStatus.text = "IO ERROR:"+Main.LANG.getParam( "送信失敗");			uploadFinished();		}		function securityErrorHandler(event:SecurityErrorEvent):void{			// セキュリティ的なエラーが出た場合			m_fileStatus.text = "SECURITY ERROR:"+Main.LANG.getParam( "送信失敗");			uploadFinished();		}			override public function setEnabled( b:Boolean):void {			super.setEnabled( b);			m_closeText.buttonMode = b;			m_btnParent.setEnabled( b);			m_btnPlus.setEnabled( b);			m_btnMinus.setEnabled( b);			m_btnMinusAll.setEnabled( b);			m_btnReload.setEnabled( b);						if( b) {				m_closeText.addEventListener( MouseEvent.CLICK, onClick_openCloseBtn);				m_btnParent.addEventListener( MouseEvent.CLICK, onParentBtnClick);				m_btnPlus.addEventListener( MouseEvent.CLICK, onPlusBtnClick);				m_btnMinus.addEventListener( MouseEvent.CLICK, onMinusBtnClick);				m_btnMinusAll.addEventListener( MouseEvent.CLICK, onAllMinusBtnClick);				m_btnReload.addEventListener( MouseEvent.CLICK, onReloadBtnClick);				m_folderCon.addEventListener( DocEvent.SELECTED, reDispatchDocEvent);				m_folderCon.addEventListener( DocEvent.REMOVED, reDispatchDocEvent);			} else {				m_closeText.removeEventListener( MouseEvent.CLICK, onClick_openCloseBtn);				m_btnParent.removeEventListener( MouseEvent.CLICK, onParentBtnClick);				m_btnPlus.removeEventListener( MouseEvent.CLICK, onPlusBtnClick);				m_btnMinus.removeEventListener( MouseEvent.CLICK, onMinusBtnClick);				m_btnMinusAll.removeEventListener( MouseEvent.CLICK, onAllMinusBtnClick);				m_btnReload.removeEventListener( MouseEvent.CLICK, onReloadBtnClick);				m_folderCon.removeEventListener( DocEvent.SELECTED, reDispatchDocEvent);				m_folderCon.removeEventListener( DocEvent.REMOVED, reDispatchDocEvent);			}		}				// ImgdocWindowから呼ばれる		public function setListType( type:String) {//trace( type);						m_folderCon.setListType( type);			m_container.y = ( type == ListTypeBtn.TEXT_CLICKED) ? INIT_Y_TYPE_TEXT : INIT_Y_TYPE_THUMB;			m_scroll.setScrollTarget( m_container); // m_scrollのinitYを再設定するため、m_container.yが変更されたらこれを呼ぶ			m_scroll.setBarYMin();//trace("getViewWidth()",getViewWidth());			m_preW--;			m_preH --;			setViewWidth( getViewWidth());			setViewHeight( getViewHeight());						if( m_uploadingCnt == 0) m_fileStatus.text = "";//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "setListType():"+ "  " + Math.random());								}		function onClick_openCloseBtn( e:MouseEvent) {			if( getViewWidth() > MIN_W) {				dispatchEvent( new Event( CLOSED));			} else {				dispatchEvent( new Event( OPENED));			}		}		override public function setViewWidth( w:Number, debug:String = ""):void {						if( w < MIN_W) w = MIN_W;			super.setViewWidth( w);									// なんどもスクロールのupdate()を呼ぶと何故かちょっとずつずれてしまうので、			// サイズがかわらないのであればここでリターン			if( w == m_preW ) return;						//m_thumbs.setViewWidth( w - m_scroll.width - PAD_THUMBS * 2);			m_folderCon.setViewWidth( w - m_scroll.width - PAD_THUMBS * 2);									m_closeText.x = w - m_closeText.width - 6;						m_containerMask.width = w - m_scroll.width;			m_scroll.x = w - m_scroll.width;												if( w > MIN_W) {				m_closeText.visible = false;				m_container.visible = m_scroll.visible = m_btnCon.visible = true;			} else {				m_closeText.visible = true;				m_container.visible =  m_scroll.visible = m_btnCon.visible = false;			}						if(  m_btnCon.visible) m_btnCon.visible = (( m_folderCon.getListtype() == ListTypeBtn.TEXT_CLICKED) ? false : true);						m_preW = w;			m_scroll.update();					}		override public function setViewHeight( h:Number):void {//trace( "start");			// なんどもスクロールのupdate()を呼ぶと何故かちょっとずつずれてしまうので、			// サイズがかわらないのであればここでリターン			if( h == m_preH ) return;							if( h < MIN_H) h = MIN_H;			super.setViewHeight( h);						var INIT_Y = (( m_folderCon.getListtype() == ListTypeBtn.TEXT_CLICKED) ? INIT_Y_TYPE_TEXT : INIT_Y_TYPE_THUMB);			m_container.y = INIT_Y;			m_scroll.y = INIT_Y;			m_containerMask.y = m_container.y;			m_containerMask.height = h - INIT_Y - FOOTER_H;			m_preH = h;			m_scroll.setSize( m_scroll.width, h - INIT_Y - FOOTER_H);			m_scroll.update();//if( ExternalInterface.available) ExternalInterface.call( "flashFunc_title", "setViewHeight" + " "+ Math.random());			//trace( "end");		}				function reDispatchDocEvent( e:DocEvent) { dispatchEvent( new DocEvent( e.type, e.doc));}		function alertDialog( str) {			Main.addErrMsg( "ImgdocContainer:" + str);		}		function errDialog( str) {			Main.addErrMsg( "ImgdocContainer:" + str);		}	}}import window.whiteboard.imgdoc.Doc;import window.whiteboard.imgdoc.DocEvent;import flash.events.EventDispatcher;import flash.events.Event;class MultiUploadManager extends EventDispatcher {	public var id;	public var addedCnt:int;	public var docArr:Array;	public function MultiUploadManager() {		addedCnt = 0;		docArr = new Array();	}	public function watchDoc( doc:Doc){		docArr.push( doc);		doc.addEventListener( DocEvent.ADDED, onDocAdded_manual);	}	function onDocAdded_manual( e:DocEvent) {		//dispatchEvent( new DocEvent( DocEvent.ADDED_MANUAL, e.doc));		Doc( e.target).removeEventListener( DocEvent.ADDED, onDocAdded_manual);		addedCnt++;		if( addedCnt == docArr.length) dispatchEvent( new Event( "complete"));	}}