package window.whiteboard.toolchip {	import flash.display.*;	import flash.geom.*;	import common.*;	import window.*;	import window.whiteboard.*;	import flash.text.*;	import flash.events.*;	import window.whiteboard.slide.*;		// ツールチップコンテナ	public class ToolchipContainer extends ResizableContainer {		static public const OPENED:String = "OPENED";		static public const CLOSED:String = "CLOSED";		static public const TOOLMODEDETAIL_CHANGE:String = "TOOLMODEDETAIL_CHANGE";		private const PAD = 8;		private const INIT_Y = 25;		private const MIN_VISIBLE_H = 50;		protected var m_openCloseBtn:OpenCloseBtn;		protected var m_closeText;		private var m_toolModeDetailHash:Object; // 全ペイントツールモード		private var m_tool_name:String;  // 現在のペイントツールモード				private var m_toolnameText:TextField;		private var m_container:Sprite;		private var m_containerMask:Sprite;		private var m_scroll:SimpleScrollBar;						private var m_preW:Number = 0;		private var m_preH:Number = 0;				public function ToolchipContainer() {			super( OpenCloseBtn.W, 200, OpenCloseBtn.W, OpenCloseBtn.H, /*0xE5EAEE*/Main.BASE_COLOR_01);						m_openCloseBtn = OpenCloseBtn( addChild( new OpenCloseBtn()));						m_closeText = addChild( Main.LANG.getToolchipCloseText());			m_closeText.y = OpenCloseBtn.H + 5;						//trace(getViewWidth());			if( getViewWidth() > OpenCloseBtn.W) {				m_openCloseBtn.setArrowLeft();				m_closeText.visible = false;			} else {				m_openCloseBtn.setArrowRight();				m_closeText.visible = true;			}									// ツールモードのデフォルト設定			m_toolModeDetailHash = new Object();			m_toolModeDetailHash[ WhiteboardContainer.TOOL_ARROW] = new ToolModeDetail( WhiteboardContainer.TOOL_ARROW);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_PENCIL] = new ToolModeDetail( WhiteboardContainer.TOOL_PENCIL);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_SMOOTH] = new ToolModeDetail( WhiteboardContainer.TOOL_SMOOTH);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_ZOOMIN] = new ToolModeDetail( WhiteboardContainer.TOOL_ZOOMIN);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_ZOOMOUT] = new ToolModeDetail( WhiteboardContainer.TOOL_ZOOMOUT);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_LINE] = new ToolModeDetail( WhiteboardContainer.TOOL_LINE);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_SQUARE] = new ToolModeDetail( WhiteboardContainer.TOOL_SQUARE);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_CIRCLE] = new ToolModeDetail( WhiteboardContainer.TOOL_CIRCLE);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_TEXT] = new ToolModeDetail( WhiteboardContainer.TOOL_TEXT);			m_toolModeDetailHash[ WhiteboardContainer.TOOL_ERASER] = new ToolModeDetail( WhiteboardContainer.TOOL_ERASER);			m_toolnameText = TextField( addChild( new TextField()));			//m_toolnameText.autoSize = TextFieldAutoSize.LEFT;			m_toolnameText.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), 12, 0x000000);			m_toolnameText.x = PAD;			m_toolnameText.y = 3;						// 表示コンテナ			m_container = Sprite( addChild( new Sprite()));			m_container.x = PAD;			m_container.y = INIT_Y;						// 表示コンテナのマスク			m_containerMask = Sprite( addChild( new Sprite()));			m_containerMask.graphics.beginFill(0);			m_containerMask.graphics.drawRect( 0, 0, 1, 1);			m_containerMask.x = m_container.x;			m_containerMask.y = m_container.y;			m_container.mask = m_containerMask;						// 表示コンテナのスクロールバー			m_scroll = SimpleScrollBar( addChild( new SimpleScrollBar()));			m_scroll.y = INIT_Y;			m_scroll.setSize( m_scroll.width, 200);			m_scroll.setScrollTarget( m_container);			m_scroll.scrollMask = m_containerMask;						for each( var toolModeDetail in m_toolModeDetailHash) {				toolModeDetail.addEventListener( ToolModeDetail.CHANGE,					function( e:*){ dispatchEvent( new Event( TOOLMODEDETAIL_CHANGE))});				toolModeDetail.addEventListener( ToolModeDetail.CONTAINER_SIZE_CHANGED,					function( e:*){						m_scroll.update();					});				toolModeDetail.addEventListener( ScaleComboEvent.CHANGED,					function( e:ScaleComboEvent){						dispatchEvent( new ScaleComboEvent( e.type, e.tool_name, e.scale));					});			}		}				// 権限変更時にWhiteboardWindow経由でWhiteboardContainerから呼ばれる		public function setAuthority( b:Boolean) {			ToolModeDetail( m_toolModeDetailHash[ WhiteboardContainer.TOOL_ARROW]).setAuthority( b);		}				public function setToolMode( tool_name:String) {			m_toolnameText.text = m_tool_name = tool_name;			while( m_container.numChildren) m_container.removeChildAt( 0);			m_container.addChild( m_toolModeDetailHash[ m_tool_name]);			m_preW--;			m_preH--;			m_scroll.update();					}		public function getCurrentToolMode() : ToolModeDetail {			return m_toolModeDetailHash[ m_tool_name];		}		public function applyToolModeDetail( simpleToolModeDetail:SimpleToolModeDetail) {			if( m_toolModeDetailHash[ simpleToolModeDetail.tool_name] != undefined) {				ToolModeDetail( m_toolModeDetailHash[ simpleToolModeDetail.tool_name]).apply( simpleToolModeDetail);			}		}				// ToolchipBtnsのSimpleToolModeDetail初期化のため、WhiteboardContainerから呼ばれる		public function getToolModeDetail( tool_name:String) : ToolModeDetail {			return m_toolModeDetailHash[ tool_name];		}				// WhiteboardContainerから呼ばれる		// 拡大縮小率のコンボボックスの値を変更する		public function setScaleCombo( scale:Number) {			var str_scale:String = String( Math.floor( scale * 100)) + "%"			ToolModeDetail( m_toolModeDetailHash[ WhiteboardContainer.TOOL_ZOOMIN]).setScaleCombo( str_scale);			ToolModeDetail( m_toolModeDetailHash[ WhiteboardContainer.TOOL_ZOOMOUT]).setScaleCombo( str_scale);		}						// テキストペイントパーツがダブルクリックされたとき、WhiteboardContainer:changeTool()から呼ばれる		// 強制的にそのテキストペイントパーツの内容とToolModeDetailの内容を合わせる		public function setTextToolModeDetail( ppd:PaintPartsData) {			ToolModeDetail( m_toolModeDetailHash[ WhiteboardContainer.TOOL_TEXT]).set( ppd);		}				/*		// WhiteboardContainerから呼ばれる。		// 画面モードが同期モードの場合にパネルを閉じて開かないようにするため		public function lock( b:Boolean) {			setEnabled( !b);		}*/		// WhiteboardContainerから呼ばれる。		public function close() {			m_openCloseBtn.setArrowRight();			dispatchEvent( new Event( CLOSED));		}		// WhiteboardContainerから呼ばれる。		public function open() {			m_openCloseBtn.setArrowLeft();			dispatchEvent( new Event( OPENED));		}						override public function setEnabled( b:Boolean):void {			super.setEnabled( b);			m_openCloseBtn.setEnabled( b);			m_closeText.buttonMode = b;			if( b) {				m_openCloseBtn.addEventListener( MouseEvent.CLICK, onClick_openCloseBtn);				m_closeText.addEventListener( MouseEvent.CLICK, onClick_openCloseBtn);			} else {				m_openCloseBtn.removeEventListener( MouseEvent.CLICK, onClick_openCloseBtn);				m_closeText.removeEventListener( MouseEvent.CLICK, onClick_openCloseBtn);			}		}				function onClick_openCloseBtn( e:MouseEvent) {			if( getViewWidth() > MIN_W) {				m_openCloseBtn.setArrowRight();				dispatchEvent( new Event( CLOSED));			} else {				m_openCloseBtn.setArrowLeft();				dispatchEvent( new Event( OPENED));			}		}				override public function setViewWidth( w:Number, debug:String = ""):void {			if( w < MIN_W) w = MIN_W;			super.setViewWidth( w);						if( w > MIN_W) m_openCloseBtn.setArrowLeft();			else m_openCloseBtn.setArrowRight();			m_closeText.x = w - m_closeText.width - 6;			m_openCloseBtn.x = w - m_openCloseBtn.width;						if( w > MIN_W) {				m_closeText.visible = false;				if( getViewHeight() > MIN_VISIBLE_H) {					m_container.visible = m_scroll.visible = m_toolnameText.visible = true;				} else {					m_container.visible = m_scroll.visible = false;				}			} else {				m_closeText.visible = true;				m_container.visible =  m_scroll.visible = m_toolnameText.visible = false;			}			m_toolnameText.width = w - m_openCloseBtn.width - m_toolnameText.x - 2;			m_containerMask.width = w - m_scroll.width;			m_scroll.x = w - m_scroll.width;						// なんどもスクロールのupdate()を呼ぶと何故かちょっとずつずれてしまうので、			// サイズがかわらないのであればここでリターン			if( w != m_preW ) {				m_preW = w;				m_scroll.update();			}		}		override public function setViewHeight( h:Number):void {			if( h < MIN_H) h = MIN_H;			super.setViewHeight( h);						m_containerMask.height = h - INIT_Y;						if( h > MIN_VISIBLE_H && getViewWidth() > MIN_W) {				m_container.visible = m_scroll.visible = m_toolnameText.visible = true;			} else {				m_container.visible = m_scroll.visible = false;			}						// なんどもスクロールのupdate()を呼ぶと何故かちょっとずつずれてしまうので、			// サイズがかわらないのであればここでリターン			if( h != m_preH ) {				m_preH = h;				m_scroll.setSize( m_scroll.width, h - INIT_Y);				m_scroll.update();			}		}							}}