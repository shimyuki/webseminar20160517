package window.setting {	import flash.display.*;	import fl.controls.ComboBox;	import fl.events.*;	import common.*;	import window.*;	import partition.*;	import flash.events.*;	import flash.text.*;		// 環境設定の画面モード作成／編集（ビュー）用コンポーネントセットの、受講生一覧の分割	public class MemberListLayout_pickup extends MemberListLayout {				private var m_btnAddRow:DynamicTextBtn; // 一行追加ボタン		private var m_btnLeftAlign:DynamicTextBtn; // 左詰めボタン		private var m_notice:TextField; /// 注意書き		private var m_footer:Sprite; // フッターコンテナ		public function MemberListLayout_pickup() {			super();						// -------------			// フッター生成			m_footer = Sprite( addChild( new Sprite())); 			// 一行追加ボタン			m_btnAddRow = DynamicTextBtn( m_footer.addChild( new DynamicTextBtn( Main.LANG.getParam( "1行追加"))));			m_btnAddRow.setEnabled( true);			m_btnAddRow.addEventListener( MouseEvent.CLICK, addRow);						// 左詰めボタン			m_btnLeftAlign = DynamicTextBtn( m_footer.addChild( new DynamicTextBtn( Main.LANG.getParam( "使用しないブロックを詰める"))));			m_btnLeftAlign.setEnabled( true);			m_btnLeftAlign.x = m_btnAddRow.x + m_btnAddRow.width + 5;			m_btnLeftAlign.addEventListener( MouseEvent.CLICK, removeVacantCell);						// 注意書き			m_notice = TextField( m_footer.addChild( new TextField()));			m_notice.text = Main.LANG.getParam( "※ 保存時に使用しないブロックは自動で詰められます");			m_notice.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), 10);			m_notice.autoSize = TextFieldAutoSize.LEFT;			m_notice.x = m_btnLeftAlign.x + m_btnLeftAlign.width + 5;			m_notice.y = ( m_btnLeftAlign.height - m_notice.height) / 2;		}				// ==================		// TEST		// ==================		/*		override public function getSelectedUidArr() : Array {			if( m_selectedUidArr == null) {				m_selectedUidArr = new Array();			} else {				while( m_selectedUidArr.length) m_selectedUidArr.pop();			}			for each( var cell in m_cellArr) {				if( cell.getSelectedUid() != null){//alertDialog( cell.getSelectedUid());					m_selectedUidArr.push( cell.getSelectedUid());				}			}			return m_selectedUidArr;		}*/				// 左詰めボタンクリック		function removeVacantCell( e:MouseEvent = null) {			for( var i = 0; i < m_cellArr.length; i++) {				if( Cell_pickup( m_cellArr[i]).getSelectedUid() == null) { // 空					var removedCell:Cell_pickup = m_cellArr.splice( i, 1)[0];					removedCell.unload();					if( contains( removedCell)) removeChild( removedCell);					// removedCell.removeEventListener();					i--;				}			}			changeCols( m_cols);		}				// 一行追加ボタンクリック		function addRow( e:MouseEvent = null) {			for( var i = 0; i < m_cols; i++) {				var add_cell:Cell_pickup = Cell_pickup( addChild( new Cell_pickup( "", ( W - PAD * ( m_cols - 1)) / m_cols, m_allUidArr)));				m_cellArr.push( add_cell);			}			replace();		}		function replace() {			var posi_x = 0;			var posi_y = 0;			for( var i = 0; i < m_cellArr.length; i++) {				var cell = m_cellArr[i];				cell.x = posi_x;				cell.y = posi_y;				posi_x += cell.getViewWidth() + PAD;				if( posi_x + cell.getViewWidth() > W) {					// 次は新しい行					posi_x = 0;					posi_y += cell.getViewHeight() + PAD;				}			}			heightChanged();		}				// 列数の変更時		override public function changeCols( cols) {			// 余分な空のセルは削除、足りない部分は空のセルを追加。			// 例えば4列だった場合、			//		→4の倍数から余るセル（最後の1〜3個）が全て空だった場合は削除。			//		→4の倍数から余るセル（最後の1〜3個）のうちどれかが			//		　空でなかった場合は4の倍数にぴったりになるようにセルを追加。			var i:uint;			// そもそもセルの数が列数以下（足りない）場合は空のセルを追加			while( m_cellArr.length < cols) {				var add_cell:Cell_pickup = Cell_pickup( addChild( new Cell_pickup( "", ( W - PAD * ( cols - 1)) / cols, m_allUidArr)));				m_cellArr.push( add_cell);			}						var amari = m_cellArr.length % cols;			if( amari != 0) {								if( getLastVacantCellNum() >= amari) { // 最後の空セルつづきが余剰セル分以上あるか					// 余剰セルは全て空なので余剰分のセルは削除					var removeCellArr:Array = m_cellArr.splice( - amari);					for each( var removedCell in removeCellArr) {						removedCell.unload();						if( contains( removedCell)) removeChild( removedCell);						// removedCell.removeEventListener();					}				} else {					// 余剰セルのうちどれかは空でないので、空のセルを追加					for( i = 0; i < cols - amari; i++) {						var new_cell:Cell_pickup = Cell_pickup( addChild( new Cell_pickup( "", ( W - PAD * ( cols - 1)) / cols, m_allUidArr)));						m_cellArr.push( new_cell);					}				}			}						// この時点で余剰セルはゼロ			// さらに最後の列が全て空だった場合、列ごと削除			while( getLastVacantCellNum() >= cols) {				if( m_cellArr.length == cols) break; // 全列削除しちゃわないように。				var removedCellArr:Array = m_cellArr.splice( - cols);				for each( var removeCell in removedCellArr) {					removeCell.unload();					if( contains( removeCell)) removeChild( removeCell);					// removedCell.removeEventListener();				}			}						super.changeCols( cols);		}		override protected function heightChanged() {			m_footer.y = super.getViewHeight() + 15;			super.heightChanged();		}		override public function getViewHeight(): Number {			var h:Number = super.getViewHeight();			return h + 15 + m_footer.height + 15;		}				// m_cellArrの最後の何個分が空かを返す		function getLastVacantCellNum():int {			var vacant_cnt:int = 0;			for( var i:int = m_cellArr.length - 1; i >= 0; i--) {				if( Cell_pickup( m_cellArr[i]).getSelectedUid() == null) { // 空					vacant_cnt++;				} else {					break;				}			}			return vacant_cnt;		}		// uidArrが[]の場合は空のセルを一行出す。		public function init( cols:int, uidArr:Array = null) {						super.reset( cols, uidArr); // m_uidArrとm_cellArrをリセット					// uidArrが[]の場合は空のセルを一行分生成するので、空のuidを入れる			if( m_uidArr.length == 0) {				for( var i = 0; i < cols; i++) {					m_uidArr.push( "");				}			}						// セル配列生成			var posi_x = 0;			var posi_y = 0;			for each( var uid:String in m_uidArr) {				var cell:Cell_pickup = Cell_pickup( addChild( new Cell_pickup( uid, ( W - PAD * ( cols - 1)) / cols, m_allUidArr)));				m_cellArr.push( cell);								cell.x = posi_x;				cell.y = posi_y;				posi_x += cell.getViewWidth() + PAD;				if( posi_x + cell.getViewWidth() > W) {					// 次は新しい行					posi_x = 0;					posi_y += cell.getViewHeight() + PAD;				}			}			heightChanged();						m_notice.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), 10);			m_notice.text = Main.LANG.getParam( "※ 保存時に使用しないブロックは自動で詰められます");			m_notice.x = m_btnLeftAlign.x + m_btnLeftAlign.width + 5;			m_notice.y = ( m_btnLeftAlign.height - m_notice.height) / 2;		}	}}