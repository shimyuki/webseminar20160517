package window.video.list.parts {	import flash.display.*;	import flash.geom.*;	import common.*;	import window.*;	import flash.text.*;	import flash.events.*;	import fl.controls.CheckBox;	import flash.net.*;	import caurina.transitions.*;	import window.video.VoiceMeter;	import window.video.VolumeCtl;	// 受講生一覧のメンバー表示コンテナのテキスト表示のコンテナ	public class TextCon extends Sprite {				private const LABEL_ATTEND_INIT = "　　　　"; // 途中で変わっても横幅は変られないので、最大文字数にそろえる		private const LABEL_ATTEND_NO = Main.LANG.getParam( "未出席　"); // 途中で変わっても横幅は変られないので、最大文字数にそろえる		private const LABEL_ATTEND_IN = Main.LANG.getParam( "出席中　"); // 途中で変わっても横幅は変られないので、最大文字数にそろえる		private const LABEL_ATTEND_OUT = Main.LANG.getParam( "通信切断"); // 途中で変わっても横幅は変られないので、最大文字数にそろえる		private const LABEL_HERE = Main.LANG.getParam( "挙手中　"); // 途中で変わっても横幅は変られないので、最大文字数にそろえる		private const LABEL_DETAIL = Main.LANG.getParam( "詳細");				static public const TEXT_CON_H = 40;		static public const PAD = 12;				private var m_uid:String;		private var m_nc:NetConnection = null;				private var m_nameTxt:TextField;		private var m_attendTxt:TextField;		private var m_camChk:CheckBox;		private var m_micChk:CheckBox;		private var m_volumeMeter:VoiceMeter;		private var m_wbChk:CheckBox;		private var m_btnDetail:DynamicTextBtn;		private var m_volumeCtl:VolumeCtl;		private var m_mobileIcon:IconMobile;				private var so:SharedObject = null;				// チェックボックスが変更されたらSOも変更する		// DBへの反映はここではやらない				public function TextCon( uid:String) {			m_uid = uid;			m_nameTxt = TextField( addChild( getText( Main.CONF.getName( m_uid))));			m_attendTxt = TextField( addChild( getText( LABEL_ATTEND_INIT)));			m_camChk = CheckBox( addChild( new CheckBox()));			m_micChk = CheckBox( addChild( new CheckBox()));			m_volumeMeter = VoiceMeter( addChild( new VoiceMeter( 125, 15)));			m_wbChk = CheckBox( addChild( new CheckBox()));			m_btnDetail = DynamicTextBtn( addChild( new DynamicTextBtn( LABEL_DETAIL)));			m_volumeCtl = VolumeCtl( addChild( new VolumeCtl( 0, 100, Main.CONF.isPro( m_uid) ? false : true)));			m_volumeCtl.setViewWidth( m_volumeMeter.width + VolumeCtl.W);												// モバイルマーク			m_mobileIcon = IconMobile( addChild( new IconMobile()));			m_mobileIcon.visible = false;									m_camChk.label = "";			m_micChk.label = "";			m_wbChk.label = "";			m_camChk.textField.width = 0;			m_micChk.textField.width = 0;			m_wbChk.textField.width = 0;			m_camChk.setSize( 30, 20);			m_micChk.setSize( 30, 20);			m_wbChk.setSize( 30, 20);						m_btnDetail.setEnabled( true);						m_nameTxt.y = m_attendTxt.y = ( TEXT_CON_H - m_nameTxt.height) / 2;			m_camChk.y = m_micChk.y = m_wbChk.y = ( TEXT_CON_H - m_camChk.height) / 2;			m_volumeMeter.y = ( TEXT_CON_H - m_volumeMeter.height) / 2;			m_volumeCtl.y = m_volumeMeter.y - ( m_volumeCtl.height - m_volumeMeter.height) / 2;			m_btnDetail.y = ( TEXT_CON_H - m_btnDetail.height) / 2;			m_mobileIcon.y = ( TEXT_CON_H - m_mobileIcon.height) / 2;						resetTextPosiX();						if(! Main.CONF.isPro( Main.CONF.UID)) {				// 受講生の場合				// チェックボックスは編集不可、詳細ボタンは非表示に。				m_camChk.enabled = false;				m_micChk.enabled = false;				m_wbChk.enabled = false;				m_btnDetail.visible = false;				m_volumeCtl.visible = false;			}						// 講師の場合もSO接続前は編集不可			m_camChk.enabled = false;			m_micChk.enabled = false;			m_wbChk.enabled = false;			m_volumeCtl.visible = false;			m_btnDetail.addEventListener( MouseEvent.CLICK, onClick_mada);		}				// LiveStatusManager経由で呼ばれる		public function setTerminalStatus( terminalType:String) {			switch( terminalType) {				case Main.TERMINAL_PC:					m_mobileIcon.visible = false;					break;				case Main.TERMINAL_ANDROID:					m_mobileIcon.visible = true;					break;			}		}		// ハイ		public function here() {			m_attendTxt.text = LABEL_HERE;		}		// 挙手取りやめ		public function hereOff() {			m_attendTxt.text = LABEL_ATTEND_IN;		}		// 欠席		public function absence() {			if( m_attendTxt.text == LABEL_ATTEND_INIT) m_attendTxt.text = LABEL_ATTEND_NO;			else m_attendTxt.text = LABEL_ATTEND_OUT;		}		// 出席		public function attend() {			m_attendTxt.text = LABEL_ATTEND_IN;		}				// 詳細ボタンクリック（SO接続前）		function onClick_mada( e:MouseEvent) {			alertDialog( Main.LANG.getParam( "通信エラー"));		}		// 詳細ボタンクリック		function onClick_detail( e:MouseEvent) {			dispatchEvent( new MemberEvent( MemberEvent.POPUP_SETTING, m_uid));		}				// 映像チェックボックス変更		// 講師の場合だけ呼ばれる		function onChangeCam( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			if( m_camChk.selected && hash.video != 1) {				hash.video = 1;				Main.CONF.resetSo_member( m_uid, hash);			} else if( ! m_camChk.selected && hash.video == 1) {				hash.video = 0;				Main.CONF.resetSo_member( m_uid, hash);			}		}				// マイクチェックボックス変更		// 講師の場合だけ呼ばれる		function onChangeMic( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			if( m_micChk.selected && hash.mic != 1) {				hash.mic = 1;				Main.CONF.resetSo_member( m_uid, hash);			} else if( ! m_micChk.selected && hash.mic == 1) {				hash.mic = 0;				Main.CONF.resetSo_member( m_uid, hash);			}		}				// WBチェックボックス変更		// 講師の場合だけ呼ばれる		function onChangeWb( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			if( m_wbChk.selected && hash.whiteboard != 1) {				hash.whiteboard = 1;				Main.CONF.resetSo_member( m_uid, hash);			} else if( ! m_wbChk.selected && hash.whiteboard == 1) {				hash.whiteboard = 0;				Main.CONF.resetSo_member( m_uid, hash);			}		}				public function initSo( nc:NetConnection) : void {			// このメンバーのSOの変更を音声や映像のチェックボックスに反映させる				m_nc = nc;						// この人の動画配信設定の変更を監視する			if( so == null) {				so = Main.CONF.getSo( m_uid);				if( so != null) {					if( Main.CONF.isPro( Main.CONF.UID)) {						// 最初の一回でいいんだけど…						m_camChk.enabled = true;						m_micChk.enabled = true;						m_wbChk.enabled = true;						m_volumeCtl.visible = true;						m_camChk.addEventListener( Event.CHANGE, onChangeCam);						m_micChk.addEventListener( Event.CHANGE, onChangeMic);						m_wbChk.addEventListener( Event.CHANGE, onChangeWb);						m_btnDetail.removeEventListener( MouseEvent.CLICK, onClick_mada);						m_btnDetail.addEventListener( MouseEvent.CLICK, onClick_detail);						m_volumeCtl.addEventListener( Event.CHANGE, changeSoGain);						m_volumeCtl.addEventListener( VolumeCtl.MUTE_OFF, changeSoMicOn);						m_volumeCtl.addEventListener( VolumeCtl.MUTE_ON, changeSoMicOff);					}										so.addEventListener( SyncEvent.SYNC, function( e:SyncEvent):void {						if( so.data.hash != undefined) {							Main.CONF.apply_member( m_uid, so.data.hash); // CONFを更新							m_camChk.selected = so.data.hash.video == 1 ? true : false;							m_micChk.selected = so.data.hash.mic == 1 ? true : false;							m_wbChk.selected = so.data.hash.whiteboard == 1 ? true : false;							m_volumeCtl.setMute( so.data.hash.mic == 1 ? false : true);							if( so.data.hash.gain != m_volumeCtl.getVolume()) m_volumeCtl.setVolume( so.data.hash.gain);						}					});				}			}								}		public function setVolume( volume:Number) {			m_volumeMeter.setLevel( volume);		}				// この人のm_volumeCtl（ゲイン）変更時		// 講師の場合だけ呼ばれる		function changeSoGain( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			hash.gain = m_volumeCtl.getVolume();			Main.CONF.resetSo_member( m_uid, hash);		}				// この人の音声権限変更時		// 講師の場合だけ呼ばれる		function changeSoMicOn( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			hash.mic = 1;			Main.CONF.resetSo_member( m_uid, hash);		}				// この人の音声権限変更時		// 講師の場合だけ呼ばれる		function changeSoMicOff( e:Event) {			var hash:Object = Main.CONF.getMemberDataHash( m_uid);			hash.mic = 0;			Main.CONF.resetSo_member( m_uid, hash);		}			// テキスト表示用パーツのX座標位置を再設定		function resetTextPosiX() {			m_nameTxt.x = PAD;			m_mobileIcon.x = m_nameTxt.x + m_nameTxt.width + PAD;			m_attendTxt.x = m_nameTxt.x + m_nameTxt.width + PAD*2.5;			m_camChk.x = m_attendTxt.x + m_attendTxt.width + PAD*2;			m_micChk.x = m_camChk.x + m_camChk.width + PAD;			if( Main.CONF.isPro( Main.CONF.UID)) {				m_volumeMeter.x = m_micChk.x + m_micChk.width + PAD + VolumeCtl.W;			} else {				m_volumeMeter.x = m_micChk.x + m_micChk.width + PAD;			}			m_wbChk.x = m_volumeMeter.x + m_volumeMeter.width + PAD;				m_btnDetail.x = m_wbChk.x + m_wbChk.width + 100;			m_volumeCtl.x = m_volumeMeter.x - VolumeCtl.W;		}						public function setBg( bgColor:uint) { // テキスト表示関連の関数						// ベース			var w = getViewWidth();			graphics.clear();			graphics.beginFill( bgColor);			graphics.drawRect( 0, 0, w, TEXT_CON_H);			graphics.endFill();			graphics.lineStyle( 1, 0xd9d9d9);			graphics.moveTo( 0, TEXT_CON_H);			graphics.lineTo( w, TEXT_CON_H);		}						public function getNameW(){ // テキスト表示関連の関数			return m_nameTxt.width + PAD*2;		}		public function getAttendW(){ // テキスト表示関連の関数			return m_attendTxt.width + PAD*2;		}		public function getCamW(){ // テキスト表示関連の関数			return m_camChk.width + PAD;		}		public function getMicW(){ // テキスト表示関連の関数			return m_micChk.width + PAD + m_volumeMeter.width + PAD;		}		public function getWbW(){ // テキスト表示関連の関数			return m_wbChk.width + PAD;		}		public function setNameW( w){ // テキスト表示関連の関数			m_nameTxt.width = w - PAD*2;			resetTextPosiX();		}		public function setAttendW( w){ // テキスト表示関連の関数			m_attendTxt.width = w - PAD*2;			resetTextPosiX();		}		public function setCamW( w){ // テキスト表示関連の関数					}		public function setMicW( w){ // テキスト表示関連の関数					}		public function setWbW( w){ // テキスト表示関連の関数			m_wbChk.x = m_volumeMeter.x + m_volumeMeter.width + ( w - m_wbChk.width)/2;		}		public function getViewWidth() : Number {			return m_btnDetail.x + m_btnDetail.width + PAD;		}		public function setViewWidth( w: Number)  {			// なにもしないでしょ		}						function getText( str:String) : TextField {			var txt = new TextField();			txt.defaultTextFormat = new TextFormat( Main.CONF.getMainFont(), 12);			txt.text = str;			txt.width = txt.textWidth + 4;			txt.height = txt.textHeight + 4;			return txt;		}		function alertDialog( str) {			Main.addErrMsg( "TextCon:" + String( str));		}							}}